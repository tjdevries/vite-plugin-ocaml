// Generated by Melange

import * as Caml_js_exceptions from "melange.js/caml_js_exceptions.js";
import * as Caml_option from "melange.js/caml_option.js";
import * as Curry from "melange.js/curry.js";
import * as Stdlib from "melange/stdlib.js";

function make(param) {
  return {
          length: 0,
          first: undefined,
          last: undefined
        };
}

function clear(q) {
  q.length = 0;
  q.first = undefined;
  q.last = undefined;
}

function add(q, x) {
  const cell = {
    content: x,
    next: undefined
  };
  const last = q.last;
  if (last !== undefined) {
    q.length = q.length + 1 | 0;
    Caml_option.valFromOption(last).next = cell;
    q.last = cell;
  } else {
    q.length = 1;
    q.first = cell;
    q.last = cell;
  }
}

function peek(q) {
  const v = q.first;
  if (v !== undefined) {
    return Caml_option.some(Caml_option.valFromOption(v).content);
  }
  
}

function peekUndefined(q) {
  const v = q.first;
  if (v !== undefined) {
    return Caml_option.valFromOption(v).content;
  }
  
}

function peekExn(q) {
  const v = q.first;
  if (v !== undefined) {
    return Caml_option.valFromOption(v).content;
  }
  throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
            MEL_EXN_ID: Stdlib.Not_found
          });
}

function pop(q) {
  const x = q.first;
  if (x === undefined) {
    return ;
  }
  const x$1 = Caml_option.valFromOption(x);
  const next = x$1.next;
  if (next === undefined) {
    clear(q);
    return Caml_option.some(x$1.content);
  } else {
    q.length = q.length - 1 | 0;
    q.first = next;
    return Caml_option.some(x$1.content);
  }
}

function popExn(q) {
  const x = q.first;
  if (x !== undefined) {
    const x$1 = Caml_option.valFromOption(x);
    const next = x$1.next;
    if (next === undefined) {
      clear(q);
      return x$1.content;
    } else {
      q.length = q.length - 1 | 0;
      q.first = next;
      return x$1.content;
    }
  }
  throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
            MEL_EXN_ID: Stdlib.Not_found
          });
}

function popUndefined(q) {
  const x = q.first;
  if (x === undefined) {
    return ;
  }
  const x$1 = Caml_option.valFromOption(x);
  const next = x$1.next;
  if (next === undefined) {
    clear(q);
    return x$1.content;
  } else {
    q.length = q.length - 1 | 0;
    q.first = next;
    return x$1.content;
  }
}

function copy(q) {
  let qRes = {
    length: q.length,
    first: undefined,
    last: undefined
  };
  let _prev;
  let _cell = q.first;
  while(true) {
    const cell = _cell;
    const prev = _prev;
    if (cell !== undefined) {
      const x = Caml_option.valFromOption(cell);
      const content = x.content;
      const res = {
        content: content,
        next: undefined
      };
      if (prev !== undefined) {
        Caml_option.valFromOption(prev).next = res;
      } else {
        qRes.first = res;
      }
      _cell = x.next;
      _prev = res;
      continue ;
    }
    qRes.last = prev;
    return qRes;
  };
}

function mapU(q, f) {
  let qRes = {
    length: q.length,
    first: undefined,
    last: undefined
  };
  let _prev;
  let _cell = q.first;
  while(true) {
    const cell = _cell;
    const prev = _prev;
    if (cell !== undefined) {
      const x = Caml_option.valFromOption(cell);
      const content = f(x.content);
      const res = {
        content: content,
        next: undefined
      };
      if (prev !== undefined) {
        Caml_option.valFromOption(prev).next = res;
      } else {
        qRes.first = res;
      }
      _cell = x.next;
      _prev = res;
      continue ;
    }
    qRes.last = prev;
    return qRes;
  };
}

function map(q, f) {
  return mapU(q, Curry.__1(f));
}

function isEmpty(q) {
  return q.length === 0;
}

function size(q) {
  return q.length;
}

function forEachU(q, f) {
  let _cell = q.first;
  while(true) {
    const cell = _cell;
    if (cell === undefined) {
      return ;
    }
    const x = Caml_option.valFromOption(cell);
    f(x.content);
    _cell = x.next;
    continue ;
  };
}

function forEach(q, f) {
  forEachU(q, Curry.__1(f));
}

function reduceU(q, accu, f) {
  let _accu = accu;
  let _cell = q.first;
  while(true) {
    const cell = _cell;
    const accu$1 = _accu;
    if (cell === undefined) {
      return accu$1;
    }
    const x = Caml_option.valFromOption(cell);
    const accu$2 = f(accu$1, x.content);
    _cell = x.next;
    _accu = accu$2;
    continue ;
  };
}

function reduce(q, accu, f) {
  return reduceU(q, accu, Curry.__2(f));
}

function transfer(q1, q2) {
  if (q1.length <= 0) {
    return ;
  }
  const l = q2.last;
  if (l !== undefined) {
    q2.length = q2.length + q1.length | 0;
    Caml_option.valFromOption(l).next = q1.first;
    q2.last = q1.last;
    return clear(q1);
  } else {
    q2.length = q1.length;
    q2.first = q1.first;
    q2.last = q1.last;
    return clear(q1);
  }
}

function fillAux(_i, arr, _cell) {
  while(true) {
    const cell = _cell;
    const i = _i;
    if (cell === undefined) {
      return ;
    }
    const x = Caml_option.valFromOption(cell);
    arr[i] = x.content;
    _cell = x.next;
    _i = i + 1 | 0;
    continue ;
  };
}

function toArray(x) {
  const v = new Array(x.length);
  fillAux(0, v, x.first);
  return v;
}

function fromArray(arr) {
  const q = {
    length: 0,
    first: undefined,
    last: undefined
  };
  for(let i = 0 ,i_finish = arr.length; i < i_finish; ++i){
    add(q, arr[i]);
  }
  return q;
}

export {
  make ,
  clear ,
  isEmpty ,
  fromArray ,
  add ,
  peek ,
  peekUndefined ,
  peekExn ,
  pop ,
  popUndefined ,
  popExn ,
  copy ,
  size ,
  mapU ,
  map ,
  forEachU ,
  forEach ,
  reduceU ,
  reduce ,
  transfer ,
  toArray ,
}
/* No side effect */
