// Generated by Melange

import * as Caml_array from "melange.js/caml_array.js";
import * as Caml_bytes from "melange.js/caml_bytes.js";
import * as Caml_exceptions from "melange.js/caml_exceptions.js";
import * as Caml_external_polyfill from "melange.js/caml_external_polyfill.js";
import * as Caml_format from "melange.js/caml_format.js";
import * as Caml_io from "melange.js/caml_io.js";
import * as Caml_js_exceptions from "melange.js/caml_js_exceptions.js";
import * as Caml_obj from "melange.js/caml_obj.js";
import * as Caml_string from "melange.js/caml_string.js";
import * as Caml_sys from "melange.js/caml_sys.js";
import * as Curry from "melange.js/curry.js";
import * as Stdlib from "./stdlib.js";
import * as Stdlib__Array from "./array.js";
import * as Stdlib__Buffer from "./buffer.js";
import * as Stdlib__Bytes from "./bytes.js";
import * as Stdlib__Int from "./int.js";
import * as Stdlib__List from "./list.js";
import * as Stdlib__Printf from "./printf.js";
import * as Stdlib__String from "./string.js";

const Bad = /* @__PURE__ */Caml_exceptions.create("Stdlib.Arg.Bad");

const Help = /* @__PURE__ */Caml_exceptions.create("Stdlib.Arg.Help");

const Stop = /* @__PURE__ */Caml_exceptions.create("Stdlib.Arg.Stop");

function assoc3(x, _l) {
  while(true) {
    const l = _l;
    if (l) {
      const match = l.hd;
      if (Caml_obj.caml_equal(match[0], x)) {
        return match[1];
      }
      _l = l.tl;
      continue ;
    }
    throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
              MEL_EXN_ID: Stdlib.Not_found
            });
  };
}

function split(s) {
  const i = Stdlib__String.index(s, /* '=' */61);
  const len = s.length;
  return [
          Stdlib__String.sub(s, 0, i),
          Stdlib__String.sub(s, i + 1 | 0, len - (i + 1 | 0) | 0)
        ];
}

function make_symlist(prefix, sep, suffix, l) {
  if (l) {
    return Stdlib__List.fold_left((function (x, y) {
                  return x + (sep + y);
                }), prefix + l.hd, l.tl) + suffix;
  } else {
    return "<none>";
  }
}

function help_action(param) {
  throw new Caml_js_exceptions.MelangeError(Stop, {
            MEL_EXN_ID: Stop,
            _1: {
              TAG: /* Unknown */0,
              _0: "-help"
            }
          });
}

function add_help(speclist) {
  let add1;
  try {
    assoc3("-help", speclist);
    add1 = /* [] */0;
  }
  catch (raw_exn){
    const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Stdlib.Not_found) {
      add1 = {
        hd: [
          "-help",
          {
            TAG: /* Unit */0,
            _0: help_action
          },
          " Display this list of options"
        ],
        tl: /* [] */0
      };
    } else {
      throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
    }
  }
  let add2;
  try {
    assoc3("--help", speclist);
    add2 = /* [] */0;
  }
  catch (raw_exn$1){
    const exn$1 = Caml_js_exceptions.internalToOCamlException(raw_exn$1);
    if (exn$1.MEL_EXN_ID === Stdlib.Not_found) {
      add2 = {
        hd: [
          "--help",
          {
            TAG: /* Unit */0,
            _0: help_action
          },
          " Display this list of options"
        ],
        tl: /* [] */0
      };
    } else {
      throw new Caml_js_exceptions.MelangeError(exn$1.MEL_EXN_ID, exn$1);
    }
  }
  return Stdlib.$at(speclist, Stdlib.$at(add1, add2));
}

function usage_b(buf, speclist, errmsg) {
  Curry._1(Stdlib__Printf.bprintf(buf, /* Format */{
            _0: {
              TAG: /* String */2,
              _0: /* No_padding */0,
              _1: {
                TAG: /* Char_literal */12,
                _0: /* '\n' */10,
                _1: /* End_of_format */0
              }
            },
            _1: "%s\n"
          }), errmsg);
  Stdlib__List.iter((function (param) {
          const doc = param[2];
          if (doc.length === 0) {
            return ;
          }
          const spec = param[1];
          const key = param[0];
          if (spec.TAG === /* Symbol */11) {
            return Curry._3(Stdlib__Printf.bprintf(buf, /* Format */{
                            _0: {
                              TAG: /* String_literal */11,
                              _0: "  ",
                              _1: {
                                TAG: /* String */2,
                                _0: /* No_padding */0,
                                _1: {
                                  TAG: /* Char_literal */12,
                                  _0: /* ' ' */32,
                                  _1: {
                                    TAG: /* String */2,
                                    _0: /* No_padding */0,
                                    _1: {
                                      TAG: /* String */2,
                                      _0: /* No_padding */0,
                                      _1: {
                                        TAG: /* Char_literal */12,
                                        _0: /* '\n' */10,
                                        _1: /* End_of_format */0
                                      }
                                    }
                                  }
                                }
                              }
                            },
                            _1: "  %s %s%s\n"
                          }), key, make_symlist("{", "|", "}", spec._0), doc);
          } else {
            return Curry._2(Stdlib__Printf.bprintf(buf, /* Format */{
                            _0: {
                              TAG: /* String_literal */11,
                              _0: "  ",
                              _1: {
                                TAG: /* String */2,
                                _0: /* No_padding */0,
                                _1: {
                                  TAG: /* Char_literal */12,
                                  _0: /* ' ' */32,
                                  _1: {
                                    TAG: /* String */2,
                                    _0: /* No_padding */0,
                                    _1: {
                                      TAG: /* Char_literal */12,
                                      _0: /* '\n' */10,
                                      _1: /* End_of_format */0
                                    }
                                  }
                                }
                              }
                            },
                            _1: "  %s %s\n"
                          }), key, doc);
          }
        }), add_help(speclist));
}

function usage_string(speclist, errmsg) {
  const b = Stdlib__Buffer.create(200);
  usage_b(b, speclist, errmsg);
  return Stdlib__Buffer.contents(b);
}

function usage(speclist, errmsg) {
  Curry._1(Stdlib__Printf.eprintf(/* Format */{
            _0: {
              TAG: /* String */2,
              _0: /* No_padding */0,
              _1: /* End_of_format */0
            },
            _1: "%s"
          }), usage_string(speclist, errmsg));
}

const current = {
  contents: 0
};

function bool_of_string_opt(x) {
  try {
    return Stdlib.bool_of_string(x);
  }
  catch (raw_exn){
    const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Stdlib.Invalid_argument) {
      return ;
    }
    throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
  }
}

function int_of_string_opt(x) {
  try {
    return Caml_format.caml_int_of_string(x);
  }
  catch (raw_exn){
    const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Stdlib.Failure) {
      return ;
    }
    throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
  }
}

function float_of_string_opt(x) {
  try {
    return Caml_format.caml_float_of_string(x);
  }
  catch (raw_exn){
    const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Stdlib.Failure) {
      return ;
    }
    throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
  }
}

function parse_and_expand_argv_dynamic_aux(allow_expand, current, argv, speclist, anonfun, errmsg) {
  const initpos = current.contents;
  const convert_error = function (error) {
    const b = Stdlib__Buffer.create(200);
    const progname = initpos < argv.contents.length ? Caml_array.get(argv.contents, initpos) : "(?)";
    switch (error.TAG | 0) {
      case /* Unknown */0 :
          const s = error._0;
          switch (s) {
            case "--help" :
            case "-help" :
                break;
            default:
              Curry._2(Stdlib__Printf.bprintf(b, /* Format */{
                        _0: {
                          TAG: /* String */2,
                          _0: /* No_padding */0,
                          _1: {
                            TAG: /* String_literal */11,
                            _0: ": unknown option '",
                            _1: {
                              TAG: /* String */2,
                              _0: /* No_padding */0,
                              _1: {
                                TAG: /* String_literal */11,
                                _0: "'.\n",
                                _1: /* End_of_format */0
                              }
                            }
                          }
                        },
                        _1: "%s: unknown option '%s'.\n"
                      }), progname, s);
          }
          break;
      case /* Wrong */1 :
          Curry._4(Stdlib__Printf.bprintf(b, /* Format */{
                    _0: {
                      TAG: /* String */2,
                      _0: /* No_padding */0,
                      _1: {
                        TAG: /* String_literal */11,
                        _0: ": wrong argument '",
                        _1: {
                          TAG: /* String */2,
                          _0: /* No_padding */0,
                          _1: {
                            TAG: /* String_literal */11,
                            _0: "'; option '",
                            _1: {
                              TAG: /* String */2,
                              _0: /* No_padding */0,
                              _1: {
                                TAG: /* String_literal */11,
                                _0: "' expects ",
                                _1: {
                                  TAG: /* String */2,
                                  _0: /* No_padding */0,
                                  _1: {
                                    TAG: /* String_literal */11,
                                    _0: ".\n",
                                    _1: /* End_of_format */0
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    },
                    _1: "%s: wrong argument '%s'; option '%s' expects %s.\n"
                  }), progname, error._1, error._0, error._2);
          break;
      case /* Missing */2 :
          Curry._2(Stdlib__Printf.bprintf(b, /* Format */{
                    _0: {
                      TAG: /* String */2,
                      _0: /* No_padding */0,
                      _1: {
                        TAG: /* String_literal */11,
                        _0: ": option '",
                        _1: {
                          TAG: /* String */2,
                          _0: /* No_padding */0,
                          _1: {
                            TAG: /* String_literal */11,
                            _0: "' needs an argument.\n",
                            _1: /* End_of_format */0
                          }
                        }
                      }
                    },
                    _1: "%s: option '%s' needs an argument.\n"
                  }), progname, error._0);
          break;
      case /* Message */3 :
          Curry._2(Stdlib__Printf.bprintf(b, /* Format */{
                    _0: {
                      TAG: /* String */2,
                      _0: /* No_padding */0,
                      _1: {
                        TAG: /* String_literal */11,
                        _0: ": ",
                        _1: {
                          TAG: /* String */2,
                          _0: /* No_padding */0,
                          _1: {
                            TAG: /* String_literal */11,
                            _0: ".\n",
                            _1: /* End_of_format */0
                          }
                        }
                      }
                    },
                    _1: "%s: %s.\n"
                  }), progname, error._0);
          break;
      
    }
    usage_b(b, speclist.contents, errmsg);
    if (Caml_obj.caml_equal(error, {
            TAG: /* Unknown */0,
            _0: "-help"
          }) || Caml_obj.caml_equal(error, {
            TAG: /* Unknown */0,
            _0: "--help"
          })) {
      return {
              MEL_EXN_ID: Help,
              _1: Stdlib__Buffer.contents(b)
            };
    } else {
      return {
              MEL_EXN_ID: Bad,
              _1: Stdlib__Buffer.contents(b)
            };
    }
  };
  current.contents = current.contents + 1 | 0;
  while(current.contents < argv.contents.length) {
    try {
      const s = Caml_array.get(argv.contents, current.contents);
      if (Stdlib__String.starts_with("-", s)) {
        let match;
        try {
          match = [
            assoc3(s, speclist.contents),
            undefined
          ];
        }
        catch (raw_exn){
          const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
          if (exn.MEL_EXN_ID === Stdlib.Not_found) {
            try {
              const match$1 = split(s);
              match = [
                assoc3(match$1[0], speclist.contents),
                match$1[1]
              ];
            }
            catch (raw_exn$1){
              const exn$1 = Caml_js_exceptions.internalToOCamlException(raw_exn$1);
              if (exn$1.MEL_EXN_ID === Stdlib.Not_found) {
                throw new Caml_js_exceptions.MelangeError(Stop, {
                          MEL_EXN_ID: Stop,
                          _1: {
                            TAG: /* Unknown */0,
                            _0: s
                          }
                        });
              }
              throw new Caml_js_exceptions.MelangeError(exn$1.MEL_EXN_ID, exn$1);
            }
          } else {
            throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
          }
        }
        const follow = match[1];
        const no_arg = function (param) {
          if (follow === undefined) {
            return ;
          }
          throw new Caml_js_exceptions.MelangeError(Stop, {
                    MEL_EXN_ID: Stop,
                    _1: {
                      TAG: /* Wrong */1,
                      _0: s,
                      _1: follow,
                      _2: "no argument"
                    }
                  });
        };
        const get_arg = function (param) {
          if (follow !== undefined) {
            return follow;
          }
          if ((current.contents + 1 | 0) < argv.contents.length) {
            return Caml_array.get(argv.contents, current.contents + 1 | 0);
          }
          throw new Caml_js_exceptions.MelangeError(Stop, {
                    MEL_EXN_ID: Stop,
                    _1: {
                      TAG: /* Missing */2,
                      _0: s
                    }
                  });
        };
        const consume_arg = function (param) {
          if (follow !== undefined) {
            return ;
          } else {
            current.contents = current.contents + 1 | 0;
            return ;
          }
        };
        const treat_action = function (f) {
          switch (f.TAG | 0) {
            case /* Unit */0 :
                no_arg(undefined);
                return Curry._1(f._0, undefined);
            case /* Bool */1 :
                const arg = get_arg(undefined);
                const s$1 = bool_of_string_opt(arg);
                if (s$1 !== undefined) {
                  Curry._1(f._0, s$1);
                } else {
                  throw new Caml_js_exceptions.MelangeError(Stop, {
                            MEL_EXN_ID: Stop,
                            _1: {
                              TAG: /* Wrong */1,
                              _0: s,
                              _1: arg,
                              _2: "a boolean"
                            }
                          });
                }
                return consume_arg(undefined);
            case /* Set */2 :
                no_arg(undefined);
                f._0.contents = true;
                return ;
            case /* Clear */3 :
                no_arg(undefined);
                f._0.contents = false;
                return ;
            case /* String */4 :
                const arg$1 = get_arg(undefined);
                Curry._1(f._0, arg$1);
                return consume_arg(undefined);
            case /* Set_string */5 :
                f._0.contents = get_arg(undefined);
                return consume_arg(undefined);
            case /* Int */6 :
                const arg$2 = get_arg(undefined);
                const x = int_of_string_opt(arg$2);
                if (x !== undefined) {
                  Curry._1(f._0, x);
                } else {
                  throw new Caml_js_exceptions.MelangeError(Stop, {
                            MEL_EXN_ID: Stop,
                            _1: {
                              TAG: /* Wrong */1,
                              _0: s,
                              _1: arg$2,
                              _2: "an integer"
                            }
                          });
                }
                return consume_arg(undefined);
            case /* Set_int */7 :
                const arg$3 = get_arg(undefined);
                const x$1 = int_of_string_opt(arg$3);
                if (x$1 !== undefined) {
                  f._0.contents = x$1;
                } else {
                  throw new Caml_js_exceptions.MelangeError(Stop, {
                            MEL_EXN_ID: Stop,
                            _1: {
                              TAG: /* Wrong */1,
                              _0: s,
                              _1: arg$3,
                              _2: "an integer"
                            }
                          });
                }
                return consume_arg(undefined);
            case /* Float */8 :
                const arg$4 = get_arg(undefined);
                const x$2 = float_of_string_opt(arg$4);
                if (x$2 !== undefined) {
                  Curry._1(f._0, x$2);
                } else {
                  throw new Caml_js_exceptions.MelangeError(Stop, {
                            MEL_EXN_ID: Stop,
                            _1: {
                              TAG: /* Wrong */1,
                              _0: s,
                              _1: arg$4,
                              _2: "a float"
                            }
                          });
                }
                return consume_arg(undefined);
            case /* Set_float */9 :
                const arg$5 = get_arg(undefined);
                const x$3 = float_of_string_opt(arg$5);
                if (x$3 !== undefined) {
                  f._0.contents = x$3;
                } else {
                  throw new Caml_js_exceptions.MelangeError(Stop, {
                            MEL_EXN_ID: Stop,
                            _1: {
                              TAG: /* Wrong */1,
                              _0: s,
                              _1: arg$5,
                              _2: "a float"
                            }
                          });
                }
                return consume_arg(undefined);
            case /* Tuple */10 :
                no_arg(undefined);
                return Stdlib__List.iter(treat_action, f._0);
            case /* Symbol */11 :
                const symb = f._0;
                const arg$6 = get_arg(undefined);
                if (Stdlib__List.mem(arg$6, symb)) {
                  Curry._1(f._1, arg$6);
                  return consume_arg(undefined);
                }
                throw new Caml_js_exceptions.MelangeError(Stop, {
                          MEL_EXN_ID: Stop,
                          _1: {
                            TAG: /* Wrong */1,
                            _0: s,
                            _1: arg$6,
                            _2: "one of: " + make_symlist("", " ", "", symb)
                          }
                        });
            case /* Rest */12 :
                const f$1 = f._0;
                no_arg(undefined);
                while(current.contents < (argv.contents.length - 1 | 0)) {
                  Curry._1(f$1, Caml_array.get(argv.contents, current.contents + 1 | 0));
                  consume_arg(undefined);
                };
                return ;
            case /* Rest_all */13 :
                no_arg(undefined);
                let acc = /* [] */0;
                while(current.contents < (argv.contents.length - 1 | 0)) {
                  acc = {
                    hd: Caml_array.get(argv.contents, current.contents + 1 | 0),
                    tl: acc
                  };
                  consume_arg(undefined);
                };
                return Curry._1(f._0, Stdlib__List.rev(acc));
            case /* Expand */14 :
                if (!allow_expand) {
                  throw new Caml_js_exceptions.MelangeError(Stdlib.Invalid_argument, {
                            MEL_EXN_ID: Stdlib.Invalid_argument,
                            _1: "Arg.Expand is is only allowed with Arg.parse_and_expand_argv_dynamic"
                          });
                }
                const arg$7 = get_arg(undefined);
                const newarg = Curry._1(f._0, arg$7);
                consume_arg(undefined);
                const before = Stdlib__Array.sub(argv.contents, 0, current.contents + 1 | 0);
                const after = Stdlib__Array.sub(argv.contents, current.contents + 1 | 0, (argv.contents.length - current.contents | 0) - 1 | 0);
                argv.contents = Caml_array.concat({
                      hd: before,
                      tl: {
                        hd: newarg,
                        tl: {
                          hd: after,
                          tl: /* [] */0
                        }
                      }
                    });
                return ;
            
          }
        };
        treat_action(match[0]);
      } else {
        Curry._1(anonfun, s);
      }
    }
    catch (raw_m){
      const m = Caml_js_exceptions.internalToOCamlException(raw_m);
      if (m.MEL_EXN_ID === Bad) {
        throw new Caml_js_exceptions.MelangeError(convert_error({
                      TAG: /* Message */3,
                      _0: m._1
                    }).MEL_EXN_ID, convert_error({
                      TAG: /* Message */3,
                      _0: m._1
                    }));
      }
      if (m.MEL_EXN_ID === Stop) {
        throw new Caml_js_exceptions.MelangeError(convert_error(m._1).MEL_EXN_ID, convert_error(m._1));
      }
      throw new Caml_js_exceptions.MelangeError(m.MEL_EXN_ID, m);
    }
    current.contents = current.contents + 1 | 0;
  };
}

function parse_and_expand_argv_dynamic(current, argv, speclist, anonfun, errmsg) {
  parse_and_expand_argv_dynamic_aux(true, current, argv, speclist, anonfun, errmsg);
}

function parse_argv_dynamic(currentOpt, argv, speclist, anonfun, errmsg) {
  const current$1 = currentOpt !== undefined ? currentOpt : current;
  parse_and_expand_argv_dynamic_aux(false, current$1, {
        contents: argv
      }, speclist, anonfun, errmsg);
}

function parse_argv(currentOpt, argv, speclist, anonfun, errmsg) {
  const current$1 = currentOpt !== undefined ? currentOpt : current;
  parse_argv_dynamic(current$1, argv, {
        contents: speclist
      }, anonfun, errmsg);
}

function parse(l, f, msg) {
  try {
    return parse_argv(undefined, Caml_sys.caml_sys_argv(0), l, f, msg);
  }
  catch (raw_msg){
    const msg$1 = Caml_js_exceptions.internalToOCamlException(raw_msg);
    if (msg$1.MEL_EXN_ID === Bad) {
      Curry._1(Stdlib__Printf.eprintf(/* Format */{
                _0: {
                  TAG: /* String */2,
                  _0: /* No_padding */0,
                  _1: /* End_of_format */0
                },
                _1: "%s"
              }), msg$1._1);
      return Stdlib.exit(2);
    }
    if (msg$1.MEL_EXN_ID === Help) {
      Curry._1(Stdlib__Printf.printf(/* Format */{
                _0: {
                  TAG: /* String */2,
                  _0: /* No_padding */0,
                  _1: /* End_of_format */0
                },
                _1: "%s"
              }), msg$1._1);
      return Stdlib.exit(0);
    }
    throw new Caml_js_exceptions.MelangeError(msg$1.MEL_EXN_ID, msg$1);
  }
}

function parse_dynamic(l, f, msg) {
  try {
    return parse_argv_dynamic(undefined, Caml_sys.caml_sys_argv(0), l, f, msg);
  }
  catch (raw_msg){
    const msg$1 = Caml_js_exceptions.internalToOCamlException(raw_msg);
    if (msg$1.MEL_EXN_ID === Bad) {
      Curry._1(Stdlib__Printf.eprintf(/* Format */{
                _0: {
                  TAG: /* String */2,
                  _0: /* No_padding */0,
                  _1: /* End_of_format */0
                },
                _1: "%s"
              }), msg$1._1);
      return Stdlib.exit(2);
    }
    if (msg$1.MEL_EXN_ID === Help) {
      Curry._1(Stdlib__Printf.printf(/* Format */{
                _0: {
                  TAG: /* String */2,
                  _0: /* No_padding */0,
                  _1: /* End_of_format */0
                },
                _1: "%s"
              }), msg$1._1);
      return Stdlib.exit(0);
    }
    throw new Caml_js_exceptions.MelangeError(msg$1.MEL_EXN_ID, msg$1);
  }
}

function parse_expand(l, f, msg) {
  try {
    const argv = {
      contents: Caml_sys.caml_sys_argv(0)
    };
    const spec = {
      contents: l
    };
    const current$1 = {
      contents: current.contents
    };
    return parse_and_expand_argv_dynamic(current$1, argv, spec, f, msg);
  }
  catch (raw_msg){
    const msg$1 = Caml_js_exceptions.internalToOCamlException(raw_msg);
    if (msg$1.MEL_EXN_ID === Bad) {
      Curry._1(Stdlib__Printf.eprintf(/* Format */{
                _0: {
                  TAG: /* String */2,
                  _0: /* No_padding */0,
                  _1: /* End_of_format */0
                },
                _1: "%s"
              }), msg$1._1);
      return Stdlib.exit(2);
    }
    if (msg$1.MEL_EXN_ID === Help) {
      Curry._1(Stdlib__Printf.printf(/* Format */{
                _0: {
                  TAG: /* String */2,
                  _0: /* No_padding */0,
                  _1: /* End_of_format */0
                },
                _1: "%s"
              }), msg$1._1);
      return Stdlib.exit(0);
    }
    throw new Caml_js_exceptions.MelangeError(msg$1.MEL_EXN_ID, msg$1);
  }
}

function second_word(s) {
  const len = s.length;
  const loop = function (_n) {
    while(true) {
      const n = _n;
      if (n >= len) {
        return len;
      }
      if (Caml_string.get(s, n) !== /* ' ' */32) {
        return n;
      }
      _n = n + 1 | 0;
      continue ;
    };
  };
  let n;
  try {
    n = Stdlib__String.index(s, /* '\t' */9);
  }
  catch (raw_exn){
    const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Stdlib.Not_found) {
      let exit = 0;
      let n$1;
      try {
        n$1 = Stdlib__String.index(s, /* ' ' */32);
        exit = 2;
      }
      catch (raw_exn$1){
        const exn$1 = Caml_js_exceptions.internalToOCamlException(raw_exn$1);
        if (exn$1.MEL_EXN_ID === Stdlib.Not_found) {
          return len;
        }
        throw new Caml_js_exceptions.MelangeError(exn$1.MEL_EXN_ID, exn$1);
      }
      if (exit === 2) {
        return loop(n$1 + 1 | 0);
      }
      
    } else {
      throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
    }
  }
  return loop(n + 1 | 0);
}

function max_arg_len(cur, param) {
  const kwd = param[0];
  if (param[1].TAG === /* Symbol */11) {
    return Stdlib__Int.max(cur, kwd.length);
  } else {
    return Stdlib__Int.max(cur, kwd.length + second_word(param[2]) | 0);
  }
}

function replace_leading_tab(s) {
  const seen = {
    contents: false
  };
  return Stdlib__String.map((function (c) {
                if (c !== 9 || seen.contents) {
                  return c;
                } else {
                  seen.contents = true;
                  return /* ' ' */32;
                }
              }), s);
}

function align(limitOpt, speclist) {
  const limit = limitOpt !== undefined ? limitOpt : Stdlib.max_int;
  const completed = add_help(speclist);
  const len = Stdlib__List.fold_left(max_arg_len, 0, completed);
  const len$1 = Stdlib__Int.min(len, limit);
  return Stdlib__List.map((function (param) {
                const kwd = param[0];
                const spec = param[1];
                if (param[2] === "") {
                  return param;
                }
                if (spec.TAG === /* Symbol */11) {
                  const msg = param[2];
                  const cutcol = second_word(msg);
                  const n = Stdlib__Int.max(0, len$1 - cutcol | 0) + 3 | 0;
                  const spaces = Caml_bytes.bytes_to_string(Stdlib__Bytes.make(n, /* ' ' */32));
                  return [
                          kwd,
                          spec,
                          "\n" + (spaces + replace_leading_tab(msg))
                        ];
                }
                const msg$1 = param[2];
                const spec$1 = param[1];
                const cutcol$1 = second_word(msg$1);
                const kwd_len = kwd.length;
                const diff = (len$1 - kwd_len | 0) - cutcol$1 | 0;
                if (diff <= 0) {
                  return [
                          kwd,
                          spec$1,
                          replace_leading_tab(msg$1)
                        ];
                }
                const spaces$1 = Caml_bytes.bytes_to_string(Stdlib__Bytes.make(diff, /* ' ' */32));
                const prefix = Stdlib__String.sub(replace_leading_tab(msg$1), 0, cutcol$1);
                const suffix = Stdlib__String.sub(msg$1, cutcol$1, msg$1.length - cutcol$1 | 0);
                return [
                        kwd,
                        spec$1,
                        prefix + (spaces$1 + suffix)
                      ];
              }), completed);
}

function trim_cr(s) {
  const len = s.length;
  if (len > 0 && Caml_string.get(s, len - 1 | 0) === /* '\r' */13) {
    return Stdlib__String.sub(s, 0, len - 1 | 0);
  } else {
    return s;
  }
}

function read_aux(trim, sep, file) {
  const ic = Stdlib.open_in_bin(file);
  const buf = Stdlib__Buffer.create(200);
  const words = {
    contents: /* [] */0
  };
  const stash = function (param) {
    const word = Stdlib__Buffer.contents(buf);
    const word$1 = trim ? trim_cr(word) : word;
    words.contents = {
      hd: word$1,
      tl: words.contents
    };
    buf.position = 0;
  };
  try {
    while(true) {
      const c = Caml_external_polyfill.resolve("caml_ml_input_char")(ic);
      if (c === sep) {
        stash(undefined);
      } else {
        Stdlib__Buffer.add_char(buf, c);
      }
    };
  }
  catch (raw_exn){
    const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID !== Stdlib.End_of_file) {
      throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
    }
    
  }
  if (buf.position > 0) {
    stash(undefined);
  }
  Caml_external_polyfill.resolve("caml_ml_close_channel")(ic);
  return Stdlib__Array.of_list(Stdlib__List.rev(words.contents));
}

function read_arg(param) {
  return read_aux(true, /* '\n' */10, param);
}

function read_arg0(param) {
  return read_aux(false, /* '\000' */0, param);
}

function write_aux(sep, file, args) {
  const oc = Stdlib.open_out_bin(file);
  Stdlib__Array.iter((function (s) {
          Curry._2(Stdlib__Printf.fprintf(oc, /* Format */{
                    _0: {
                      TAG: /* String */2,
                      _0: /* No_padding */0,
                      _1: {
                        TAG: /* Char */0,
                        _0: /* End_of_format */0
                      }
                    },
                    _1: "%s%c"
                  }), s, sep);
        }), args);
  Caml_io.caml_ml_flush(oc);
  Caml_external_polyfill.resolve("caml_ml_close_channel")(oc);
}

function write_arg(param, param$1) {
  return write_aux(/* '\n' */10, param, param$1);
}

function write_arg0(param, param$1) {
  return write_aux(/* '\000' */0, param, param$1);
}

export {
  parse ,
  parse_dynamic ,
  parse_argv ,
  parse_argv_dynamic ,
  parse_and_expand_argv_dynamic ,
  parse_expand ,
  Help ,
  Bad ,
  usage ,
  usage_string ,
  align ,
  current ,
  read_arg ,
  read_arg0 ,
  write_arg ,
  write_arg0 ,
}
/* No side effect */
