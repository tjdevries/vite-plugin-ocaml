// Generated by Melange

import * as Caml from "melange.js/caml.js";
import * as Caml_array from "melange.js/caml_array.js";
import * as Caml_js_exceptions from "melange.js/caml_js_exceptions.js";
import * as Caml_obj from "melange.js/caml_obj.js";
import * as Caml_oo from "melange.js/caml_oo.js";
import * as Caml_string from "melange.js/caml_string.js";
import * as Curry from "melange.js/curry.js";
import * as Stdlib from "./stdlib.js";
import * as Stdlib__Array from "./array.js";
import * as Stdlib__List from "./list.js";

const new_object_tag_block = (function(size){
  var v = new Array(size)
  v.TAG = 248 // tag
  return v
}
);

function copy(o) {
  return Caml_oo.caml_set_oo_id(Caml_obj.caml_obj_dup(o));
}

const params = {
  compact_table: true,
  copy_parent: true,
  clean_when_copying: true,
  retry_count: 3,
  bucket_small_size: 16
};

function public_method_label(s) {
  let accu = 0;
  for(let i = 0 ,i_finish = s.length; i < i_finish; ++i){
    accu = Math.imul(223, accu) + Caml_string.get(s, i) | 0;
  }
  accu = accu & 2147483647;
  if (accu > 1073741823) {
    return accu - -2147483648 | 0;
  } else {
    return accu;
  }
}

const compare = Caml.caml_string_compare;

const funarg = {
  compare: compare
};

function height(param) {
  if (param) {
    return param.h;
  } else {
    return 0;
  }
}

function create(l, x, d, r) {
  const hl = height(l);
  const hr = height(r);
  return /* Node */{
          l: l,
          v: x,
          d: d,
          r: r,
          h: hl >= hr ? hl + 1 | 0 : hr + 1 | 0
        };
}

function bal(l, x, d, r) {
  const hl = l ? l.h : 0;
  const hr = r ? r.h : 0;
  if (hl > (hr + 2 | 0)) {
    if (l) {
      const lr = l.r;
      const ld = l.d;
      const lv = l.v;
      const ll = l.l;
      if (height(ll) >= height(lr)) {
        return create(ll, lv, ld, create(lr, x, d, r));
      }
      if (lr) {
        return create(create(ll, lv, ld, lr.l), lr.v, lr.d, create(lr.r, x, d, r));
      }
      throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
                MEL_EXN_ID: "Invalid_argument",
                _1: "Map.bal"
              });
    }
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
              MEL_EXN_ID: "Invalid_argument",
              _1: "Map.bal"
            });
  }
  if (hr <= (hl + 2 | 0)) {
    return /* Node */{
            l: l,
            v: x,
            d: d,
            r: r,
            h: hl >= hr ? hl + 1 | 0 : hr + 1 | 0
          };
  }
  if (r) {
    const rr = r.r;
    const rd = r.d;
    const rv = r.v;
    const rl = r.l;
    if (height(rr) >= height(rl)) {
      return create(create(l, x, d, rl), rv, rd, rr);
    }
    if (rl) {
      return create(create(l, x, d, rl.l), rl.v, rl.d, create(rl.r, rv, rd, rr));
    }
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
              MEL_EXN_ID: "Invalid_argument",
              _1: "Map.bal"
            });
  }
  throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
            MEL_EXN_ID: "Invalid_argument",
            _1: "Map.bal"
          });
}

function add(x, data, m) {
  if (!m) {
    return /* Node */{
            l: /* Empty */0,
            v: x,
            d: data,
            r: /* Empty */0,
            h: 1
          };
  }
  const r = m.r;
  const d = m.d;
  const v = m.v;
  const l = m.l;
  const c = Curry._2(funarg.compare, x, v);
  if (c === 0) {
    if (d === data) {
      return m;
    } else {
      return /* Node */{
              l: l,
              v: x,
              d: data,
              r: r,
              h: m.h
            };
    }
  }
  if (c < 0) {
    const ll = add(x, data, l);
    if (l === ll) {
      return m;
    } else {
      return bal(ll, v, d, r);
    }
  }
  const rr = add(x, data, r);
  if (r === rr) {
    return m;
  } else {
    return bal(l, v, d, rr);
  }
}

function find(x, _param) {
  while(true) {
    const param = _param;
    if (param) {
      const c = Curry._2(funarg.compare, x, param.v);
      if (c === 0) {
        return param.d;
      }
      _param = c < 0 ? param.l : param.r;
      continue ;
    }
    throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
              MEL_EXN_ID: Stdlib.Not_found
            });
  };
}

function fold(f, _m, _accu) {
  while(true) {
    const accu = _accu;
    const m = _m;
    if (!m) {
      return accu;
    }
    _accu = Curry._3(f, m.v, m.d, fold(f, m.l, accu));
    _m = m.r;
    continue ;
  };
}

const compare$1 = Caml.caml_string_compare;

const funarg$1 = {
  compare: compare$1
};

function height$1(param) {
  if (param) {
    return param.h;
  } else {
    return 0;
  }
}

function create$1(l, x, d, r) {
  const hl = height$1(l);
  const hr = height$1(r);
  return /* Node */{
          l: l,
          v: x,
          d: d,
          r: r,
          h: hl >= hr ? hl + 1 | 0 : hr + 1 | 0
        };
}

function bal$1(l, x, d, r) {
  const hl = l ? l.h : 0;
  const hr = r ? r.h : 0;
  if (hl > (hr + 2 | 0)) {
    if (l) {
      const lr = l.r;
      const ld = l.d;
      const lv = l.v;
      const ll = l.l;
      if (height$1(ll) >= height$1(lr)) {
        return create$1(ll, lv, ld, create$1(lr, x, d, r));
      }
      if (lr) {
        return create$1(create$1(ll, lv, ld, lr.l), lr.v, lr.d, create$1(lr.r, x, d, r));
      }
      throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
                MEL_EXN_ID: "Invalid_argument",
                _1: "Map.bal"
              });
    }
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
              MEL_EXN_ID: "Invalid_argument",
              _1: "Map.bal"
            });
  }
  if (hr <= (hl + 2 | 0)) {
    return /* Node */{
            l: l,
            v: x,
            d: d,
            r: r,
            h: hl >= hr ? hl + 1 | 0 : hr + 1 | 0
          };
  }
  if (r) {
    const rr = r.r;
    const rd = r.d;
    const rv = r.v;
    const rl = r.l;
    if (height$1(rr) >= height$1(rl)) {
      return create$1(create$1(l, x, d, rl), rv, rd, rr);
    }
    if (rl) {
      return create$1(create$1(l, x, d, rl.l), rl.v, rl.d, create$1(rl.r, rv, rd, rr));
    }
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
              MEL_EXN_ID: "Invalid_argument",
              _1: "Map.bal"
            });
  }
  throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
            MEL_EXN_ID: "Invalid_argument",
            _1: "Map.bal"
          });
}

function add$1(x, data, m) {
  if (!m) {
    return /* Node */{
            l: /* Empty */0,
            v: x,
            d: data,
            r: /* Empty */0,
            h: 1
          };
  }
  const r = m.r;
  const d = m.d;
  const v = m.v;
  const l = m.l;
  const c = Curry._2(funarg$1.compare, x, v);
  if (c === 0) {
    if (d === data) {
      return m;
    } else {
      return /* Node */{
              l: l,
              v: x,
              d: data,
              r: r,
              h: m.h
            };
    }
  }
  if (c < 0) {
    const ll = add$1(x, data, l);
    if (l === ll) {
      return m;
    } else {
      return bal$1(ll, v, d, r);
    }
  }
  const rr = add$1(x, data, r);
  if (r === rr) {
    return m;
  } else {
    return bal$1(l, v, d, rr);
  }
}

function find$1(x, _param) {
  while(true) {
    const param = _param;
    if (param) {
      const c = Curry._2(funarg$1.compare, x, param.v);
      if (c === 0) {
        return param.d;
      }
      _param = c < 0 ? param.l : param.r;
      continue ;
    }
    throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
              MEL_EXN_ID: Stdlib.Not_found
            });
  };
}

const compare$2 = Caml.caml_int_compare;

const funarg$2 = {
  compare: compare$2
};

function height$2(param) {
  if (param) {
    return param.h;
  } else {
    return 0;
  }
}

function create$2(l, x, d, r) {
  const hl = height$2(l);
  const hr = height$2(r);
  return /* Node */{
          l: l,
          v: x,
          d: d,
          r: r,
          h: hl >= hr ? hl + 1 | 0 : hr + 1 | 0
        };
}

function bal$2(l, x, d, r) {
  const hl = l ? l.h : 0;
  const hr = r ? r.h : 0;
  if (hl > (hr + 2 | 0)) {
    if (l) {
      const lr = l.r;
      const ld = l.d;
      const lv = l.v;
      const ll = l.l;
      if (height$2(ll) >= height$2(lr)) {
        return create$2(ll, lv, ld, create$2(lr, x, d, r));
      }
      if (lr) {
        return create$2(create$2(ll, lv, ld, lr.l), lr.v, lr.d, create$2(lr.r, x, d, r));
      }
      throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
                MEL_EXN_ID: "Invalid_argument",
                _1: "Map.bal"
              });
    }
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
              MEL_EXN_ID: "Invalid_argument",
              _1: "Map.bal"
            });
  }
  if (hr <= (hl + 2 | 0)) {
    return /* Node */{
            l: l,
            v: x,
            d: d,
            r: r,
            h: hl >= hr ? hl + 1 | 0 : hr + 1 | 0
          };
  }
  if (r) {
    const rr = r.r;
    const rd = r.d;
    const rv = r.v;
    const rl = r.l;
    if (height$2(rr) >= height$2(rl)) {
      return create$2(create$2(l, x, d, rl), rv, rd, rr);
    }
    if (rl) {
      return create$2(create$2(l, x, d, rl.l), rl.v, rl.d, create$2(rl.r, rv, rd, rr));
    }
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
              MEL_EXN_ID: "Invalid_argument",
              _1: "Map.bal"
            });
  }
  throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
            MEL_EXN_ID: "Invalid_argument",
            _1: "Map.bal"
          });
}

function add$2(x, data, m) {
  if (!m) {
    return /* Node */{
            l: /* Empty */0,
            v: x,
            d: data,
            r: /* Empty */0,
            h: 1
          };
  }
  const r = m.r;
  const d = m.d;
  const v = m.v;
  const l = m.l;
  const c = Curry._2(funarg$2.compare, x, v);
  if (c === 0) {
    if (d === data) {
      return m;
    } else {
      return /* Node */{
              l: l,
              v: x,
              d: data,
              r: r,
              h: m.h
            };
    }
  }
  if (c < 0) {
    const ll = add$2(x, data, l);
    if (l === ll) {
      return m;
    } else {
      return bal$2(ll, v, d, r);
    }
  }
  const rr = add$2(x, data, r);
  if (r === rr) {
    return m;
  } else {
    return bal$2(l, v, d, rr);
  }
}

function find$2(x, _param) {
  while(true) {
    const param = _param;
    if (param) {
      const c = Curry._2(funarg$2.compare, x, param.v);
      if (c === 0) {
        return param.d;
      }
      _param = c < 0 ? param.l : param.r;
      continue ;
    }
    throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
              MEL_EXN_ID: Stdlib.Not_found
            });
  };
}

const dummy_table = {
  size: 0,
  methods: [undefined],
  methods_by_name: /* Empty */0,
  methods_by_label: /* Empty */0,
  previous_states: /* [] */0,
  hidden_meths: /* [] */0,
  vars: /* Empty */0,
  initializers: /* [] */0
};

const table_count = {
  contents: 0
};

function fit_size(n) {
  if (n <= 2) {
    return n;
  } else {
    return (fit_size((n + 1 | 0) / 2 | 0) << 1);
  }
}

function new_table(pub_labels) {
  table_count.contents = table_count.contents + 1 | 0;
  const len = pub_labels.length;
  const methods = Caml_array.make((len << 1) + 2 | 0, /* DummyA */0);
  Caml_array.set(methods, 0, len);
  Caml_array.set(methods, 1, ((fit_size(len) << 5) / 8 | 0) - 1 | 0);
  for(let i = 0; i < len; ++i){
    Caml_array.set(methods, (i << 1) + 3 | 0, Caml_array.get(pub_labels, i));
  }
  return {
          size: 2,
          methods: methods,
          methods_by_name: /* Empty */0,
          methods_by_label: /* Empty */0,
          previous_states: /* [] */0,
          hidden_meths: /* [] */0,
          vars: /* Empty */0,
          initializers: /* [] */0
        };
}

function resize(array, new_size) {
  const old_size = array.methods.length;
  if (new_size <= old_size) {
    return ;
  }
  const new_buck = Caml_array.make(new_size, /* DummyA */0);
  Stdlib__Array.blit(array.methods, 0, new_buck, 0, old_size);
  array.methods = new_buck;
}

const method_count = {
  contents: 0
};

const inst_var_count = {
  contents: 0
};

function new_method(table) {
  const index = table.methods.length;
  resize(table, index + 1 | 0);
  return index;
}

function get_method_label(table, name) {
  try {
    return Curry._2(find$1, name, table.methods_by_name);
  }
  catch (raw_exn){
    const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Stdlib.Not_found) {
      const label = new_method(table);
      table.methods_by_name = Curry._3(add$1, name, label, table.methods_by_name);
      table.methods_by_label = Curry._3(add$2, label, true, table.methods_by_label);
      return label;
    }
    throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
  }
}

function get_method_labels(table, names) {
  return Stdlib__Array.map((function (param) {
                return get_method_label(table, param);
              }), names);
}

function set_method(table, label, element) {
  method_count.contents = method_count.contents + 1 | 0;
  if (Curry._2(find$2, label, table.methods_by_label)) {
    resize(table, label + 1 | 0);
    return Caml_array.set(table.methods, label, element);
  } else {
    table.hidden_meths = {
      hd: [
        label,
        element
      ],
      tl: table.hidden_meths
    };
    return ;
  }
}

function get_method(table, label) {
  try {
    return Stdlib__List.assoc(label, table.hidden_meths);
  }
  catch (raw_exn){
    const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Stdlib.Not_found) {
      return Caml_array.get(table.methods, label);
    }
    throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
  }
}

function to_list(arr) {
  if (arr === 0) {
    return /* [] */0;
  } else {
    return Stdlib__Array.to_list(arr);
  }
}

function narrow(table, vars, virt_meths, concr_meths) {
  const vars$1 = to_list(vars);
  const virt_meths$1 = to_list(virt_meths);
  const concr_meths$1 = to_list(concr_meths);
  const virt_meth_labs = Stdlib__List.map((function (param) {
          return get_method_label(table, param);
        }), virt_meths$1);
  const concr_meth_labs = Stdlib__List.map((function (param) {
          return get_method_label(table, param);
        }), concr_meths$1);
  table.previous_states = {
    hd: [
      table.methods_by_name,
      table.methods_by_label,
      table.hidden_meths,
      table.vars,
      virt_meth_labs,
      vars$1
    ],
    tl: table.previous_states
  };
  table.vars = Curry._3(fold, (function (lab, info, tvars) {
          if (Stdlib__List.mem(lab, vars$1)) {
            return Curry._3(add, lab, info, tvars);
          } else {
            return tvars;
          }
        }), table.vars, /* Empty */0);
  const by_name = {
    contents: /* Empty */0
  };
  const by_label = {
    contents: /* Empty */0
  };
  Stdlib__List.iter2((function (met, label) {
          by_name.contents = Curry._3(add$1, met, label, by_name.contents);
          let tmp;
          try {
            tmp = Curry._2(find$2, label, table.methods_by_label);
          }
          catch (raw_exn){
            const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
            if (exn.MEL_EXN_ID === Stdlib.Not_found) {
              tmp = true;
            } else {
              throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
            }
          }
          by_label.contents = Curry._3(add$2, label, tmp, by_label.contents);
        }), concr_meths$1, concr_meth_labs);
  Stdlib__List.iter2((function (met, label) {
          by_name.contents = Curry._3(add$1, met, label, by_name.contents);
          by_label.contents = Curry._3(add$2, label, false, by_label.contents);
        }), virt_meths$1, virt_meth_labs);
  table.methods_by_name = by_name.contents;
  table.methods_by_label = by_label.contents;
  table.hidden_meths = Stdlib__List.fold_right((function (met, hm) {
          if (Stdlib__List.mem(met[0], virt_meth_labs)) {
            return hm;
          } else {
            return {
                    hd: met,
                    tl: hm
                  };
          }
        }), table.hidden_meths, /* [] */0);
}

function widen(table) {
  const match = Stdlib__List.hd(table.previous_states);
  const virt_meths = match[4];
  table.previous_states = Stdlib__List.tl(table.previous_states);
  table.vars = Stdlib__List.fold_left((function (s, v) {
          return Curry._3(add, v, Curry._2(find, v, table.vars), s);
        }), match[3], match[5]);
  table.methods_by_name = match[0];
  table.methods_by_label = match[1];
  table.hidden_meths = Stdlib__List.fold_right((function (met, hm) {
          if (Stdlib__List.mem(met[0], virt_meths)) {
            return hm;
          } else {
            return {
                    hd: met,
                    tl: hm
                  };
          }
        }), table.hidden_meths, match[2]);
}

function new_slot(table) {
  const index = table.size;
  table.size = index + 1 | 0;
  return index;
}

function new_variable(table, name) {
  try {
    return Curry._2(find, name, table.vars);
  }
  catch (raw_exn){
    const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Stdlib.Not_found) {
      const index = new_slot(table);
      if (name !== "") {
        table.vars = Curry._3(add, name, index, table.vars);
      }
      return index;
    }
    throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
  }
}

function to_array(arr) {
  if (Caml_obj.caml_equal(arr, 0)) {
    return [];
  } else {
    return arr;
  }
}

function new_methods_variables(table, meths, vals) {
  const meths$1 = to_array(meths);
  const nmeths = meths$1.length;
  const nvals = vals.length;
  const res = Caml_array.make(nmeths + nvals | 0, 0);
  for(let i = 0; i < nmeths; ++i){
    Caml_array.set(res, i, get_method_label(table, Caml_array.get(meths$1, i)));
  }
  for(let i$1 = 0; i$1 < nvals; ++i$1){
    Caml_array.set(res, i$1 + nmeths | 0, new_variable(table, Caml_array.get(vals, i$1)));
  }
  return res;
}

function get_variable(table, name) {
  try {
    return Curry._2(find, name, table.vars);
  }
  catch (raw_exn){
    const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Stdlib.Not_found) {
      throw new Caml_js_exceptions.MelangeError("Assert_failure", {
                MEL_EXN_ID: "Assert_failure",
                _1: [
                  "camlinternalOO.cppo.ml",
                  301,
                  20
                ]
              });
    }
    throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
  }
}

function get_variables(table, names) {
  return Stdlib__Array.map((function (param) {
                return get_variable(table, param);
              }), names);
}

function add_initializer(table, f) {
  table.initializers = {
    hd: f,
    tl: table.initializers
  };
}

function create_table(public_methods) {
  if (public_methods === 0) {
    return new_table([]);
  }
  const tags = Stdlib__Array.map(public_method_label, public_methods);
  const table = new_table(tags);
  Stdlib__Array.iteri((function (i, met) {
          const lab = (i << 1) + 2 | 0;
          table.methods_by_name = Curry._3(add$1, met, lab, table.methods_by_name);
          table.methods_by_label = Curry._3(add$2, lab, true, table.methods_by_label);
        }), public_methods);
  return table;
}

function init_class(table) {
  inst_var_count.contents = (inst_var_count.contents + table.size | 0) - 1 | 0;
  table.initializers = Stdlib__List.rev(table.initializers);
  resize(table, 3 + ((Caml_array.get(table.methods, 1) << 4) / 32 | 0) | 0);
}

function inherits(cla, vals, virt_meths, concr_meths, param, top) {
  const $$super = param[1];
  narrow(cla, vals, virt_meths, concr_meths);
  const init = top ? Curry._2($$super, cla, param[3]) : Curry._1($$super, cla);
  widen(cla);
  return Caml_array.concat({
              hd: [init],
              tl: {
                hd: Stdlib__Array.map((function (param) {
                        return get_variable(cla, param);
                      }), to_array(vals)),
                tl: {
                  hd: Stdlib__Array.map((function (nm) {
                          return get_method(cla, get_method_label(cla, nm));
                        }), to_array(concr_meths)),
                  tl: /* [] */0
                }
              }
            });
}

function make_class(pub_meths, class_init) {
  const table = create_table(pub_meths);
  const env_init = Curry._1(class_init, table);
  init_class(table);
  return [
          Curry._1(env_init, 0),
          class_init,
          env_init,
          0
        ];
}

function make_class_store(pub_meths, class_init, init_table) {
  const table = create_table(pub_meths);
  const env_init = Curry._1(class_init, table);
  init_class(table);
  init_table.class_init = class_init;
  init_table.env_init = env_init;
}

function create_object(table) {
  const obj = new_object_tag_block(table.size);
  obj[0] = table.methods;
  return Caml_oo.caml_set_oo_id(obj);
}

function create_object_opt(obj_0, table) {
  if (obj_0) {
    return obj_0;
  }
  const obj = new_object_tag_block(table.size);
  obj[0] = table.methods;
  return Caml_oo.caml_set_oo_id(obj);
}

function iter_f(obj, _param) {
  while(true) {
    const param = _param;
    if (!param) {
      return ;
    }
    Curry._1(param.hd, obj);
    _param = param.tl;
    continue ;
  };
}

function run_initializers(obj, table) {
  const inits = table.initializers;
  if (Caml_obj.caml_notequal(inits, /* [] */0)) {
    return iter_f(obj, inits);
  }
  
}

function run_initializers_opt(obj_0, obj, table) {
  if (obj_0) {
    return obj;
  }
  const inits = table.initializers;
  if (Caml_obj.caml_notequal(inits, /* [] */0)) {
    iter_f(obj, inits);
  }
  return obj;
}

function create_object_and_run_initializers(obj_0, table) {
  if (obj_0) {
    return obj_0;
  }
  const obj = create_object(table);
  run_initializers(obj, table);
  return obj;
}

function set_data(tables, v) {
  if (tables) {
    tables.data = v;
    return ;
  }
  throw new Caml_js_exceptions.MelangeError("Assert_failure", {
            MEL_EXN_ID: "Assert_failure",
            _1: [
              "camlinternalOO.cppo.ml",
              436,
              13
            ]
          });
}

function set_next(tables, v) {
  if (tables) {
    tables.next = v;
    return ;
  }
  throw new Caml_js_exceptions.MelangeError("Assert_failure", {
            MEL_EXN_ID: "Assert_failure",
            _1: [
              "camlinternalOO.cppo.ml",
              439,
              13
            ]
          });
}

function get_key(tables) {
  if (tables) {
    return tables.key;
  }
  throw new Caml_js_exceptions.MelangeError("Assert_failure", {
            MEL_EXN_ID: "Assert_failure",
            _1: [
              "camlinternalOO.cppo.ml",
              442,
              13
            ]
          });
}

function get_data(tables) {
  if (tables) {
    return tables.data;
  }
  throw new Caml_js_exceptions.MelangeError("Assert_failure", {
            MEL_EXN_ID: "Assert_failure",
            _1: [
              "camlinternalOO.cppo.ml",
              445,
              13
            ]
          });
}

function get_next(tables) {
  if (tables) {
    return tables.next;
  }
  throw new Caml_js_exceptions.MelangeError("Assert_failure", {
            MEL_EXN_ID: "Assert_failure",
            _1: [
              "camlinternalOO.cppo.ml",
              448,
              13
            ]
          });
}

function build_path(n, keys, tables) {
  const res = /* Cons */{
    key: 0,
    data: /* Empty */0,
    next: /* Empty */0
  };
  let r = res;
  for(let i = 0; i <= n; ++i){
    r = /* Cons */{
      key: Caml_array.get(keys, i),
      data: r,
      next: /* Empty */0
    };
  }
  set_data(tables, r);
  return res;
}

function lookup_keys(i, keys, tables) {
  if (i < 0) {
    return tables;
  }
  const key = Caml_array.get(keys, i);
  let _tables = tables;
  while(true) {
    const tables$1 = _tables;
    if (get_key(tables$1) === key) {
      const tables_data = get_data(tables$1);
      if (tables_data) {
        return lookup_keys(i - 1 | 0, keys, tables_data);
      }
      throw new Caml_js_exceptions.MelangeError("Assert_failure", {
                MEL_EXN_ID: "Assert_failure",
                _1: [
                  "camlinternalOO.cppo.ml",
                  466,
                  17
                ]
              });
    }
    const next = get_next(tables$1);
    if (next) {
      _tables = next;
      continue ;
    }
    const next$1 = /* Cons */{
      key: key,
      data: /* Empty */0,
      next: /* Empty */0
    };
    set_next(tables$1, next$1);
    return build_path(i - 1 | 0, keys, next$1);
  };
}

function lookup_tables(root, keys) {
  const root_data = get_data(root);
  if (root_data) {
    return lookup_keys(keys.length - 1 | 0, keys, root_data);
  } else {
    return build_path(keys.length - 1 | 0, keys, root);
  }
}

function new_cache(table) {
  const n = new_method(table);
  const n$1 = n % 2 === 0 || n > (2 + ((Caml_array.get(table.methods, 1) << 4) / 32 | 0) | 0) ? n : new_method(table);
  Caml_array.set(table.methods, n$1, 0);
  return n$1;
}

function method_impl(table, i, arr) {
  const next = function (param) {
    i.contents = i.contents + 1 | 0;
    return Caml_array.get(arr, i.contents);
  };
  const clo = next(undefined);
  if (typeof clo !== "number") {
    return clo;
  }
  switch (clo) {
    case /* GetConst */0 :
        const x = next(undefined);
        return function (_obj) {
          return x;
        };
    case /* GetVar */1 :
        const n = next(undefined);
        return function (obj) {
          return obj[n];
        };
    case /* GetEnv */2 :
        const e = next(undefined);
        const n$1 = next(undefined);
        return function (obj) {
          return obj[e][n$1];
        };
    case /* GetMeth */3 :
        let n$2 = next(undefined);
        return function (obj) {
          return Curry._1(obj[0][n$2], obj);
        };
    case /* SetVar */4 :
        const n$3 = next(undefined);
        return function (obj, x) {
          obj[n$3] = x;
        };
    case /* AppConst */5 :
        const f = next(undefined);
        const x$1 = next(undefined);
        return function (_obj) {
          return Curry._1(f, x$1);
        };
    case /* AppVar */6 :
        const f$1 = next(undefined);
        const n$4 = next(undefined);
        return function (obj) {
          return Curry._1(f$1, obj[n$4]);
        };
    case /* AppEnv */7 :
        const f$2 = next(undefined);
        const e$1 = next(undefined);
        const n$5 = next(undefined);
        return function (obj) {
          return Curry._1(f$2, obj[e$1][n$5]);
        };
    case /* AppMeth */8 :
        const f$3 = next(undefined);
        const n$6 = next(undefined);
        return function (obj) {
          return Curry._1(f$3, Curry._1(obj[0][n$6], obj));
        };
    case /* AppConstConst */9 :
        const f$4 = next(undefined);
        const x$2 = next(undefined);
        const y = next(undefined);
        return function (_obj) {
          return Curry._2(f$4, x$2, y);
        };
    case /* AppConstVar */10 :
        const f$5 = next(undefined);
        const x$3 = next(undefined);
        const n$7 = next(undefined);
        return function (obj) {
          return Curry._2(f$5, x$3, obj[n$7]);
        };
    case /* AppConstEnv */11 :
        const f$6 = next(undefined);
        const x$4 = next(undefined);
        const e$2 = next(undefined);
        const n$8 = next(undefined);
        return function (obj) {
          return Curry._2(f$6, x$4, obj[e$2][n$8]);
        };
    case /* AppConstMeth */12 :
        const f$7 = next(undefined);
        const x$5 = next(undefined);
        const n$9 = next(undefined);
        return function (obj) {
          return Curry._2(f$7, x$5, Curry._1(obj[0][n$9], obj));
        };
    case /* AppVarConst */13 :
        const f$8 = next(undefined);
        const n$10 = next(undefined);
        const x$6 = next(undefined);
        return function (obj) {
          return Curry._2(f$8, obj[n$10], x$6);
        };
    case /* AppEnvConst */14 :
        const f$9 = next(undefined);
        const e$3 = next(undefined);
        const n$11 = next(undefined);
        const x$7 = next(undefined);
        return function (obj) {
          return Curry._2(f$9, obj[e$3][n$11], x$7);
        };
    case /* AppMethConst */15 :
        const f$10 = next(undefined);
        const n$12 = next(undefined);
        const x$8 = next(undefined);
        return function (obj) {
          return Curry._2(f$10, Curry._1(obj[0][n$12], obj), x$8);
        };
    case /* MethAppConst */16 :
        const n$13 = next(undefined);
        const x$9 = next(undefined);
        return function (obj) {
          return Curry._2(obj[0][n$13], obj, x$9);
        };
    case /* MethAppVar */17 :
        const n$14 = next(undefined);
        const m = next(undefined);
        return function (obj) {
          return Curry._2(obj[0][n$14], obj, obj[m]);
        };
    case /* MethAppEnv */18 :
        const n$15 = next(undefined);
        const e$4 = next(undefined);
        const m$1 = next(undefined);
        return function (obj) {
          return Curry._2(obj[0][n$15], obj, obj[e$4][m$1]);
        };
    case /* MethAppMeth */19 :
        const n$16 = next(undefined);
        const m$2 = next(undefined);
        return function (obj) {
          return Curry._2(obj[0][n$16], obj, Curry._1(obj[0][m$2], obj));
        };
    case /* SendConst */20 :
        const m$3 = next(undefined);
        const x$10 = next(undefined);
        let c = new_cache(table);
        return function (obj) {
          return Curry._3(Curry._3(Caml_oo.caml_get_public_method, x$10, m$3, 1), x$10, obj[0], c);
        };
    case /* SendVar */21 :
        const m$4 = next(undefined);
        const n$17 = next(undefined);
        let c$1 = new_cache(table);
        return function (obj) {
          const tmp = obj[n$17];
          return Curry._3(Curry._3(Caml_oo.caml_get_public_method, tmp, m$4, 2), tmp, obj[0], c$1);
        };
    case /* SendEnv */22 :
        const m$5 = next(undefined);
        const e$5 = next(undefined);
        const n$18 = next(undefined);
        let c$2 = new_cache(table);
        return function (obj) {
          const tmp = obj[e$5][n$18];
          return Curry._3(Curry._3(Caml_oo.caml_get_public_method, tmp, m$5, 3), tmp, obj[0], c$2);
        };
    case /* SendMeth */23 :
        const m$6 = next(undefined);
        const n$19 = next(undefined);
        let c$3 = new_cache(table);
        return function (obj) {
          const tmp = Curry._1(obj[0][n$19], obj);
          return Curry._3(Curry._3(Caml_oo.caml_get_public_method, tmp, m$6, 4), tmp, obj[0], c$3);
        };
    
  }
}

function set_methods(table, methods) {
  const len = methods.length;
  const i = {
    contents: 0
  };
  while(i.contents < len) {
    const label = Caml_array.get(methods, i.contents);
    const clo = method_impl(table, i, methods);
    set_method(table, label, clo);
    i.contents = i.contents + 1 | 0;
  };
}

function stats(param) {
  return {
          classes: table_count.contents,
          methods: method_count.contents,
          inst_vars: inst_var_count.contents
        };
}

export {
  public_method_label ,
  new_method ,
  new_variable ,
  new_methods_variables ,
  get_variable ,
  get_variables ,
  get_method_label ,
  get_method_labels ,
  get_method ,
  set_method ,
  set_methods ,
  narrow ,
  widen ,
  add_initializer ,
  dummy_table ,
  create_table ,
  init_class ,
  inherits ,
  make_class ,
  make_class_store ,
  copy ,
  create_object ,
  create_object_opt ,
  run_initializers ,
  run_initializers_opt ,
  create_object_and_run_initializers ,
  lookup_tables ,
  params ,
  stats ,
}
/* Vars Not a pure module */
