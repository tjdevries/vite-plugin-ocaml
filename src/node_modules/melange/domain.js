// Generated by Melange

import * as Caml_js_exceptions from "melange.js/caml_js_exceptions.js";
import * as Caml_option from "melange.js/caml_option.js";
import * as Curry from "melange.js/curry.js";
import * as Stdlib__Fun from "./fun.js";
import * as Stdlib__List from "./list.js";
import * as Stdlib__Printexc from "./printexc.js";
import * as Stdlib__Queue from "./queue.js";

const atomic_lock = {
  contents: false
};

function atomically(f) {
  atomic_lock.contents = true;
  return Stdlib__Fun.protect((function (param) {
                atomic_lock.contents = false;
              }), f);
}

const first_spawn_queue = {
  length: 0,
  first: /* Nil */0,
  last: /* Nil */0
};

const first_spawn_occurred = {
  contents: false
};

function before_first_spawn(f) {
  atomically(function (param) {
        if (first_spawn_occurred.contents) {
          throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
                    MEL_EXN_ID: "Invalid_argument",
                    _1: "Domain.before_first_spawn"
                  });
        }
        Stdlib__Queue.push(f, first_spawn_queue);
      });
}

function maybe_first_spawn(param) {
  atomically(function (param) {
        if (first_spawn_occurred.contents) {
          return ;
        }
        first_spawn_occurred.contents = true;
        while(first_spawn_queue.length !== 0) {
          const f = Stdlib__Queue.take(first_spawn_queue);
          Curry._1(f, undefined);
        };
      });
}

const at_exit_table = {
  contents: /* [] */0
};

function at_exit(f) {
  atomically(function (param) {
        at_exit_table.contents = {
          hd: f,
          tl: at_exit_table.contents
        };
      });
}

function get_id(t) {
  return t.id;
}

function self(param) {
  return 0;
}

function cpu_relax(param) {
  
}

function is_main_domain(param) {
  return true;
}

function recommended_domain_count(param) {
  return 1;
}

const all_keys = {
  contents: /* [] */0
};

function new_key(split_from_parent, init) {
  const key = {
    table: undefined,
    split_from_parent: split_from_parent,
    init: init
  };
  atomically(function (param) {
        all_keys.contents = {
          hd: /* Key */{
            _0: key
          },
          tl: all_keys.contents
        };
      });
  return key;
}

function get(key) {
  const v = key.table;
  if (v !== undefined) {
    return Caml_option.valFromOption(v);
  }
  const v$1 = Curry._1(key.init, undefined);
  atomically(function (param) {
        key.table = Caml_option.some(v$1);
      });
  return v$1;
}

function set(key, v) {
  atomically(function (param) {
        key.table = Caml_option.some(v);
      });
}

function prepare_split_keys_before_spawn(param) {
  return Stdlib__List.filter_map((function (key) {
                let key$1 = key._0;
                const split = key$1.split_from_parent;
                if (split === undefined) {
                  return ;
                }
                const current = get(key$1);
                const child = Curry._1(split, current);
                return /* Key_value */{
                        _0: key$1,
                        _1: child
                      };
              }), all_keys.contents);
}

function perform_split_after_spawn(split_keys) {
  const perform_split = function (param) {
    set(param._0, param._1);
  };
  Stdlib__List.iter(perform_split, split_keys);
}

const next_id = {
  contents: 0
};

function spawn(f) {
  maybe_first_spawn(undefined);
  const status = {
    contents: /* Running */0
  };
  const split_keys = prepare_split_keys_before_spawn(undefined);
  const handle = new Promise((function (resolve, reject) {
          let param = [
            split_keys,
            status
          ];
          const status$1 = param[1];
          perform_split_after_spawn(param[0]);
          let exit = 0;
          let v;
          try {
            v = Curry._1(f, undefined);
            exit = 1;
          }
          catch (raw_exn){
            const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
            let bt;
            status$1.contents = {
              TAG: /* Error */1,
              _0: exn,
              _1: bt
            };
            reject(exn);
          }
          if (exit === 1) {
            status$1.contents = {
              TAG: /* Return */0,
              _0: v
            };
            resolve(v);
          }
          const at_exit_callbacks = atomically(function (param) {
                return at_exit_table.contents;
              });
          try {
            Stdlib__List.iter((function (f) {
                    Curry._1(f, undefined);
                  }), at_exit_callbacks);
            return ;
          }
          catch (raw_exn$1){
            const exn$1 = Caml_js_exceptions.internalToOCamlException(raw_exn$1);
            const match = status$1.contents;
            if (typeof match === "number") {
              throw new Caml_js_exceptions.MelangeError("Assert_failure", {
                        MEL_EXN_ID: "Assert_failure",
                        _1: [
                          "jscomp/stdlib/domain.ml",
                          77,
                          19
                        ]
                      });
            }
            if (match.TAG !== /* Return */0) {
              return ;
            }
            let bt$1;
            status$1.contents = {
              TAG: /* Error */1,
              _0: exn$1,
              _1: bt$1
            };
            return ;
          }
        }));
  return {
          id: (next_id.contents = next_id.contents + 1 | 0, next_id.contents),
          handle: handle,
          status: status
        };
}

function join(t) {
  return t.handle.then(function (param) {
                const v = t.status.contents;
                if (typeof v === "number") {
                  throw new Caml_js_exceptions.MelangeError("Assert_failure", {
                            MEL_EXN_ID: "Assert_failure",
                            _1: [
                              "jscomp/stdlib/domain.ml",
                              179,
                              17
                            ]
                          });
                }
                if (v.TAG === /* Return */0) {
                  return Promise.resolve(v._0);
                }
                throw new Caml_js_exceptions.MelangeError(v._0.MEL_EXN_ID, v._0);
              }).catch(function (param) {
              const match = t.status.contents;
              if (typeof match === "number") {
                throw new Caml_js_exceptions.MelangeError("Assert_failure", {
                          MEL_EXN_ID: "Assert_failure",
                          _1: [
                            "jscomp/stdlib/domain.ml",
                            186,
                            30
                          ]
                        });
              }
              if (match.TAG === /* Return */0) {
                throw new Caml_js_exceptions.MelangeError("Assert_failure", {
                          MEL_EXN_ID: "Assert_failure",
                          _1: [
                            "jscomp/stdlib/domain.ml",
                            186,
                            30
                          ]
                        });
              }
              throw new Caml_js_exceptions.MelangeError(match._0.MEL_EXN_ID, match._0);
            });
}

const DLS = {
  new_key: new_key,
  get: get,
  set: set
};

export {
  spawn ,
  join ,
  get_id ,
  self ,
  before_first_spawn ,
  at_exit ,
  cpu_relax ,
  is_main_domain ,
  recommended_domain_count ,
  DLS ,
}
/* Stdlib__Fun Not a pure module */
