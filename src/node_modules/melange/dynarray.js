// Generated by Melange

import * as Caml from "melange.js/caml.js";
import * as Caml_array from "melange.js/caml_array.js";
import * as Caml_js_exceptions from "melange.js/caml_js_exceptions.js";
import * as Caml_option from "melange.js/caml_option.js";
import * as Curry from "melange.js/curry.js";
import * as Stdlib from "./stdlib.js";
import * as Stdlib__Array from "./array.js";
import * as Stdlib__List from "./list.js";
import * as Stdlib__Printf from "./printf.js";
import * as Stdlib__Seq from "./seq.js";
import * as Stdlib__Sys from "./sys.js";

function negative_length_requested(f, n) {
  return Curry._2(Stdlib__Printf.ksprintf(Stdlib.invalid_arg, /* Format */{
                  _0: {
                    TAG: /* String_literal */11,
                    _0: "Dynarray.",
                    _1: {
                      TAG: /* String */2,
                      _0: /* No_padding */0,
                      _1: {
                        TAG: /* String_literal */11,
                        _0: ": negative length ",
                        _1: {
                          TAG: /* Int */4,
                          _0: /* Int_d */0,
                          _1: /* No_padding */0,
                          _2: /* No_precision */0,
                          _3: {
                            TAG: /* String_literal */11,
                            _0: " requested",
                            _1: /* End_of_format */0
                          }
                        }
                      }
                    }
                  },
                  _1: "Dynarray.%s: negative length %d requested"
                }), f, n);
}

function negative_capacity_requested(f, n) {
  return Curry._2(Stdlib__Printf.ksprintf(Stdlib.invalid_arg, /* Format */{
                  _0: {
                    TAG: /* String_literal */11,
                    _0: "Dynarray.",
                    _1: {
                      TAG: /* String */2,
                      _0: /* No_padding */0,
                      _1: {
                        TAG: /* String_literal */11,
                        _0: ": negative capacity ",
                        _1: {
                          TAG: /* Int */4,
                          _0: /* Int_d */0,
                          _1: /* No_padding */0,
                          _2: /* No_precision */0,
                          _3: {
                            TAG: /* String_literal */11,
                            _0: " requested",
                            _1: /* End_of_format */0
                          }
                        }
                      }
                    }
                  },
                  _1: "Dynarray.%s: negative capacity %d requested"
                }), f, n);
}

function requested_length_out_of_bounds(f, requested_length) {
  return Curry._3(Stdlib__Printf.ksprintf(Stdlib.invalid_arg, /* Format */{
                  _0: {
                    TAG: /* String_literal */11,
                    _0: "Dynarray.",
                    _1: {
                      TAG: /* String */2,
                      _0: /* No_padding */0,
                      _1: {
                        TAG: /* String_literal */11,
                        _0: ": cannot grow to requested length ",
                        _1: {
                          TAG: /* Int */4,
                          _0: /* Int_d */0,
                          _1: /* No_padding */0,
                          _2: /* No_precision */0,
                          _3: {
                            TAG: /* String_literal */11,
                            _0: " (max_array_length is ",
                            _1: {
                              TAG: /* Int */4,
                              _0: /* Int_d */0,
                              _1: /* No_padding */0,
                              _2: /* No_precision */0,
                              _3: {
                                TAG: /* Char_literal */12,
                                _0: /* ')' */41,
                                _1: /* End_of_format */0
                              }
                            }
                          }
                        }
                      }
                    }
                  },
                  _1: "Dynarray.%s: cannot grow to requested length %d (max_array_length is %d)"
                }), f, requested_length, Stdlib__Sys.max_array_length);
}

const invalid_state_description = "Invalid dynarray (unsynchronized concurrent length change)";

function missing_element(i, length) {
  return Curry._3(Stdlib__Printf.ksprintf(Stdlib.invalid_arg, /* Format */{
                  _0: {
                    TAG: /* String */2,
                    _0: /* No_padding */0,
                    _1: {
                      TAG: /* String_literal */11,
                      _0: ": missing element at position ",
                      _1: {
                        TAG: /* Int */4,
                        _0: /* Int_d */0,
                        _1: /* No_padding */0,
                        _2: /* No_precision */0,
                        _3: {
                          TAG: /* String_literal */11,
                          _0: " < length ",
                          _1: {
                            TAG: /* Int */4,
                            _0: /* Int_d */0,
                            _1: /* No_padding */0,
                            _2: /* No_precision */0,
                            _3: /* End_of_format */0
                          }
                        }
                      }
                    }
                  },
                  _1: "%s: missing element at position %d < length %d"
                }), invalid_state_description, i, length);
}

function invalid_length(length, capacity) {
  return Curry._3(Stdlib__Printf.ksprintf(Stdlib.invalid_arg, /* Format */{
                  _0: {
                    TAG: /* String */2,
                    _0: /* No_padding */0,
                    _1: {
                      TAG: /* String_literal */11,
                      _0: ": length ",
                      _1: {
                        TAG: /* Int */4,
                        _0: /* Int_d */0,
                        _1: /* No_padding */0,
                        _2: /* No_precision */0,
                        _3: {
                          TAG: /* String_literal */11,
                          _0: " > capacity ",
                          _1: {
                            TAG: /* Int */4,
                            _0: /* Int_d */0,
                            _1: /* No_padding */0,
                            _2: /* No_precision */0,
                            _3: /* End_of_format */0
                          }
                        }
                      }
                    }
                  },
                  _1: "%s: length %d > capacity %d"
                }), invalid_state_description, length, capacity);
}

function unexpected_empty_element(f, i, length) {
  if (i < length) {
    return missing_element(i, length);
  } else if (length === 0) {
    return Curry._2(Stdlib__Printf.ksprintf(Stdlib.invalid_arg, /* Format */{
                    _0: {
                      TAG: /* String_literal */11,
                      _0: "Dynarray.",
                      _1: {
                        TAG: /* String */2,
                        _0: /* No_padding */0,
                        _1: {
                          TAG: /* String_literal */11,
                          _0: ": index ",
                          _1: {
                            TAG: /* Int */4,
                            _0: /* Int_d */0,
                            _1: /* No_padding */0,
                            _2: /* No_precision */0,
                            _3: {
                              TAG: /* String_literal */11,
                              _0: " out of bounds (empty dynarray)",
                              _1: /* End_of_format */0
                            }
                          }
                        }
                      }
                    },
                    _1: "Dynarray.%s: index %d out of bounds (empty dynarray)"
                  }), f, i);
  } else {
    return Curry._3(Stdlib__Printf.ksprintf(Stdlib.invalid_arg, /* Format */{
                    _0: {
                      TAG: /* String_literal */11,
                      _0: "Dynarray.",
                      _1: {
                        TAG: /* String */2,
                        _0: /* No_padding */0,
                        _1: {
                          TAG: /* String_literal */11,
                          _0: ": index ",
                          _1: {
                            TAG: /* Int */4,
                            _0: /* Int_d */0,
                            _1: /* No_padding */0,
                            _2: /* No_precision */0,
                            _3: {
                              TAG: /* String_literal */11,
                              _0: " out of bounds (0..",
                              _1: {
                                TAG: /* Int */4,
                                _0: /* Int_d */0,
                                _1: /* No_padding */0,
                                _2: /* No_precision */0,
                                _3: {
                                  TAG: /* Char_literal */12,
                                  _0: /* ')' */41,
                                  _1: /* End_of_format */0
                                }
                              }
                            }
                          }
                        }
                      }
                    },
                    _1: "Dynarray.%s: index %d out of bounds (0..%d)"
                  }), f, i, length - 1 | 0);
  }
}

function empty_dynarray(f) {
  return Curry._1(Stdlib__Printf.ksprintf(Stdlib.invalid_arg, /* Format */{
                  _0: {
                    TAG: /* String_literal */11,
                    _0: "Dynarray.",
                    _1: {
                      TAG: /* String */2,
                      _0: /* No_padding */0,
                      _1: {
                        TAG: /* String_literal */11,
                        _0: ": empty array",
                        _1: /* End_of_format */0
                      }
                    }
                  },
                  _1: "Dynarray.%s: empty array"
                }), f);
}

function check_same_length(f, a, length) {
  const length_a = a.length;
  if (length !== length_a) {
    return Curry._3(Stdlib__Printf.ksprintf(Stdlib.invalid_arg, /* Format */{
                    _0: {
                      TAG: /* String_literal */11,
                      _0: "Dynarray.",
                      _1: {
                        TAG: /* String */2,
                        _0: /* No_padding */0,
                        _1: {
                          TAG: /* String_literal */11,
                          _0: ": a length change from ",
                          _1: {
                            TAG: /* Int */4,
                            _0: /* Int_d */0,
                            _1: /* No_padding */0,
                            _2: /* No_precision */0,
                            _3: {
                              TAG: /* String_literal */11,
                              _0: " to ",
                              _1: {
                                TAG: /* Int */4,
                                _0: /* Int_d */0,
                                _1: /* No_padding */0,
                                _2: /* No_precision */0,
                                _3: {
                                  TAG: /* String_literal */11,
                                  _0: " occurred during iteration",
                                  _1: /* End_of_format */0
                                }
                              }
                            }
                          }
                        }
                      }
                    },
                    _1: "Dynarray.%s: a length change from %d to %d occurred during iteration"
                  }), f, length, length_a);
  }
  
}

function create(param) {
  return {
          length: 0,
          arr: []
        };
}

function make(n, x) {
  if (n < 0) {
    negative_length_requested("make", n);
  }
  return {
          length: n,
          arr: Stdlib__Array.init(n, (function (param) {
                  return /* Elem */{
                          v: x
                        };
                }))
        };
}

function init(n, f) {
  if (n < 0) {
    negative_length_requested("init", n);
  }
  return {
          length: n,
          arr: Stdlib__Array.init(n, (function (i) {
                  return /* Elem */{
                          v: Curry._1(f, i)
                        };
                }))
        };
}

function get(a, i) {
  const s = Caml_array.get(a.arr, i);
  if (s) {
    return s.v;
  } else {
    return unexpected_empty_element("get", i, a.length);
  }
}

function set(a, i, x) {
  const s = Caml_array.get(a.arr, i);
  if (s) {
    s.v = x;
    return ;
  } else {
    return unexpected_empty_element("set", i, a.length);
  }
}

function length(a) {
  return a.length;
}

function is_empty(a) {
  return a.length === 0;
}

function copy(param) {
  const length = param.length;
  const arr = param.arr;
  const capacity = arr.length;
  if (length > capacity) {
    invalid_length(length, capacity);
  }
  return {
          length: length,
          arr: Stdlib__Array.init(length, (function (i) {
                  const match = arr[i];
                  const v = match ? match.v : missing_element(i, length);
                  return /* Elem */{
                          v: v
                        };
                }))
        };
}

function get_last(a) {
  const length = a.length;
  const arr = a.arr;
  const capacity = arr.length;
  if (length > capacity) {
    invalid_length(length, capacity);
  }
  if (length === 0) {
    empty_dynarray("get_last");
  }
  const i = length - 1 | 0;
  const match = arr[i];
  if (match) {
    return match.v;
  } else {
    return missing_element(i, length);
  }
}

function find_last(a) {
  const length = a.length;
  const arr = a.arr;
  const capacity = arr.length;
  if (length > capacity) {
    invalid_length(length, capacity);
  }
  if (length === 0) {
    return ;
  }
  const i = length - 1 | 0;
  const match = arr[i];
  return Caml_option.some(match ? match.v : missing_element(i, length));
}

function pop_last(a) {
  const length = a.length;
  const arr = a.arr;
  const capacity = arr.length;
  if (length > capacity) {
    invalid_length(length, capacity);
  }
  if (length === 0) {
    throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
              MEL_EXN_ID: Stdlib.Not_found
            });
  }
  const last = length - 1 | 0;
  const s = arr[last];
  if (s) {
    arr[last] = /* Empty */0;
    a.length = last;
    return s.v;
  } else {
    return missing_element(last, length);
  }
}

function pop_last_opt(a) {
  let x;
  try {
    x = pop_last(a);
  }
  catch (raw_exn){
    const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Stdlib.Not_found) {
      return ;
    }
    throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
  }
  return Caml_option.some(x);
}

function remove_last(a) {
  const last = a.length - 1 | 0;
  if (last >= 0) {
    a.length = last;
    return Caml_array.set(a.arr, last, /* Empty */0);
  }
  
}

function truncate(a, n) {
  if (n < 0) {
    negative_length_requested("truncate", n);
  }
  const length = a.length;
  const arr = a.arr;
  if (length <= n) {
    return ;
  } else {
    a.length = n;
    return Stdlib__Array.fill(arr, n, length - n | 0, /* Empty */0);
  }
}

function clear(a) {
  truncate(a, 0);
}

function capacity(a) {
  return a.arr.length;
}

function next_capacity(n) {
  const n$p = n <= 512 ? (n << 1) : n + (n / 2 | 0) | 0;
  return Caml.caml_int_min(8 > n$p ? 8 : n$p, Stdlib__Sys.max_array_length);
}

function ensure_capacity(a, capacity_request) {
  const arr = a.arr;
  const cur_capacity = arr.length;
  if (capacity_request < 0) {
    return negative_capacity_requested("ensure_capacity", capacity_request);
  }
  if (cur_capacity >= capacity_request) {
    return ;
  }
  if (capacity_request > Stdlib__Sys.max_array_length) {
    requested_length_out_of_bounds("ensure_capacity", capacity_request);
  }
  const new_capacity = Caml.caml_int_max(next_capacity(cur_capacity), capacity_request);
  const new_arr = Caml_array.make(new_capacity, /* Empty */0);
  Stdlib__Array.blit(arr, 0, new_arr, 0, a.length);
  a.arr = new_arr;
  if (0 > capacity_request) {
    throw new Caml_js_exceptions.MelangeError("Assert_failure", {
              MEL_EXN_ID: "Assert_failure",
              _1: [
                "jscomp/stdlib/dynarray.ml",
                380,
                4
              ]
            });
  }
  if (capacity_request <= new_arr.length) {
    return ;
  }
  throw new Caml_js_exceptions.MelangeError("Assert_failure", {
            MEL_EXN_ID: "Assert_failure",
            _1: [
              "jscomp/stdlib/dynarray.ml",
              381,
              4
            ]
          });
}

function ensure_extra_capacity(a, extra_capacity_request) {
  ensure_capacity(a, a.length + extra_capacity_request | 0);
}

function fit_capacity(a) {
  if (a.arr.length === a.length) {
    return ;
  } else {
    a.arr = Stdlib__Array.sub(a.arr, 0, a.length);
    return ;
  }
}

function set_capacity(a, n) {
  if (n < 0) {
    negative_capacity_requested("set_capacity", n);
  }
  const arr = a.arr;
  const cur_capacity = arr.length;
  if (n < cur_capacity) {
    a.length = a.length < n ? a.length : n;
    a.arr = Stdlib__Array.sub(arr, 0, n);
    return ;
  }
  if (n <= cur_capacity) {
    return ;
  }
  const new_arr = Caml_array.make(n, /* Empty */0);
  Stdlib__Array.blit(arr, 0, new_arr, 0, a.length);
  a.arr = new_arr;
}

function reset(a) {
  a.length = 0;
  a.arr = [];
}

function add_last(a, x) {
  const elem = /* Elem */{
    v: x
  };
  const length = a.length;
  const arr = a.arr;
  if (length >= arr.length ? false : (a.length = length + 1 | 0, arr[length] = elem, true)) {
    return ;
  }
  while(true) {
    ensure_extra_capacity(a, 1);
    const length$1 = a.length;
    const arr$1 = a.arr;
    if (length$1 >= arr$1.length ? false : (a.length = length$1 + 1 | 0, arr$1[length$1] = elem, true)) {
      return ;
    }
    continue ;
  };
}

function append_list(a, _li) {
  while(true) {
    const li = _li;
    if (!li) {
      return ;
    }
    add_last(a, li.hd);
    _li = li.tl;
    continue ;
  };
}

function append_iter(a, iter, b) {
  return Curry._2(iter, (function (x) {
                add_last(a, x);
              }), b);
}

function append_seq(a, seq) {
  Stdlib__Seq.iter((function (x) {
          add_last(a, x);
        }), seq);
}

function append_array_if_room(a, b) {
  const length_a = a.length;
  const arr = a.arr;
  const length_b = b.length;
  if ((length_a + length_b | 0) > arr.length) {
    return false;
  }
  a.length = length_a + length_b | 0;
  for(let i = 0; i < length_b; ++i){
    const x = b[i];
    arr[length_a + i | 0] = /* Elem */{
      v: x
    };
  }
  return true;
}

function append_array(a, b) {
  if (append_array_if_room(a, b)) {
    return ;
  }
  while(true) {
    ensure_extra_capacity(a, b.length);
    if (append_array_if_room(a, b)) {
      return ;
    }
    continue ;
  };
}

function append_if_room(a, b, length_b) {
  const length_a = a.length;
  const arr_a = a.arr;
  if ((length_a + length_b | 0) > arr_a.length) {
    return false;
  }
  a.length = length_a + length_b | 0;
  const arr_b = b.arr;
  const capacity = arr_b.length;
  if (length_b > capacity) {
    invalid_length(length_b, capacity);
  }
  for(let i = 0; i < length_b; ++i){
    const match = arr_b[i];
    const x = match ? match.v : missing_element(i, length_b);
    arr_a[length_a + i | 0] = /* Elem */{
      v: x
    };
  }
  check_same_length("append", b, length_b);
  return true;
}

function append(a, b) {
  const length_b = b.length;
  if (append_if_room(a, b, length_b)) {
    return ;
  }
  while(true) {
    ensure_extra_capacity(a, length_b);
    check_same_length("append", b, length_b);
    if (append_if_room(a, b, length_b)) {
      return ;
    }
    continue ;
  };
}

function iter_(f, k, a) {
  const length = a.length;
  const arr = a.arr;
  const capacity = arr.length;
  if (length > capacity) {
    invalid_length(length, capacity);
  }
  for(let i = 0; i < length; ++i){
    const match = arr[i];
    Curry._1(k, match ? match.v : missing_element(i, length));
  }
  check_same_length(f, a, length);
}

function iter(k, a) {
  iter_("iter", k, a);
}

function iteri(k, a) {
  const length = a.length;
  const arr = a.arr;
  const capacity = arr.length;
  if (length > capacity) {
    invalid_length(length, capacity);
  }
  for(let i = 0; i < length; ++i){
    const match = arr[i];
    Curry._2(k, i, match ? match.v : missing_element(i, length));
  }
  check_same_length("iteri", a, length);
}

function map(f, a) {
  const length = a.length;
  const arr = a.arr;
  const capacity = arr.length;
  if (length > capacity) {
    invalid_length(length, capacity);
  }
  const res = {
    length: length,
    arr: Stdlib__Array.init(length, (function (i) {
            const match = arr[i];
            return /* Elem */{
                    v: Curry._1(f, match ? match.v : missing_element(i, length))
                  };
          }))
  };
  check_same_length("map", a, length);
  return res;
}

function mapi(f, a) {
  const length = a.length;
  const arr = a.arr;
  const capacity = arr.length;
  if (length > capacity) {
    invalid_length(length, capacity);
  }
  const res = {
    length: length,
    arr: Stdlib__Array.init(length, (function (i) {
            const match = arr[i];
            return /* Elem */{
                    v: Curry._2(f, i, match ? match.v : missing_element(i, length))
                  };
          }))
  };
  check_same_length("mapi", a, length);
  return res;
}

function fold_left(f, acc, a) {
  const length = a.length;
  const arr = a.arr;
  const capacity = arr.length;
  if (length > capacity) {
    invalid_length(length, capacity);
  }
  let r = acc;
  for(let i = 0; i < length; ++i){
    const match = arr[i];
    const v = match ? match.v : missing_element(i, length);
    r = Curry._2(f, r, v);
  }
  check_same_length("fold_left", a, length);
  return r;
}

function fold_right(f, a, acc) {
  const length = a.length;
  const arr = a.arr;
  const capacity = arr.length;
  if (length > capacity) {
    invalid_length(length, capacity);
  }
  let r = acc;
  for(let i = length - 1 | 0; i >= 0; --i){
    const match = arr[i];
    const v = match ? match.v : missing_element(i, length);
    r = Curry._2(f, v, r);
  }
  check_same_length("fold_right", a, length);
  return r;
}

function exists(p, a) {
  const length = a.length;
  const arr = a.arr;
  const capacity = arr.length;
  if (length > capacity) {
    invalid_length(length, capacity);
  }
  const loop = function (p, arr, _i, length) {
    while(true) {
      const i = _i;
      if (i === length) {
        return false;
      }
      const match = arr[i];
      if (Curry._1(p, match ? match.v : missing_element(i, length))) {
        return true;
      }
      _i = i + 1 | 0;
      continue ;
    };
  };
  const res = loop(p, arr, 0, length);
  check_same_length("exists", a, length);
  return res;
}

function for_all(p, a) {
  const length = a.length;
  const arr = a.arr;
  const capacity = arr.length;
  if (length > capacity) {
    invalid_length(length, capacity);
  }
  const loop = function (p, arr, _i, length) {
    while(true) {
      const i = _i;
      if (i === length) {
        return true;
      }
      const match = arr[i];
      if (!Curry._1(p, match ? match.v : missing_element(i, length))) {
        return false;
      }
      _i = i + 1 | 0;
      continue ;
    };
  };
  const res = loop(p, arr, 0, length);
  check_same_length("for_all", a, length);
  return res;
}

function filter(f, a) {
  const b = {
    length: 0,
    arr: []
  };
  iter_("filter", (function (x) {
          if (Curry._1(f, x)) {
            return add_last(b, x);
          }
          
        }), a);
  return b;
}

function filter_map(f, a) {
  const b = {
    length: 0,
    arr: []
  };
  iter_("filter_map", (function (x) {
          const y = Curry._1(f, x);
          if (y !== undefined) {
            return add_last(b, Caml_option.valFromOption(y));
          }
          
        }), a);
  return b;
}

function of_array(a) {
  const length = a.length;
  return {
          length: length,
          arr: Stdlib__Array.init(length, (function (i) {
                  return /* Elem */{
                          v: a[i]
                        };
                }))
        };
}

function to_array(a) {
  const length = a.length;
  const arr = a.arr;
  const capacity = arr.length;
  if (length > capacity) {
    invalid_length(length, capacity);
  }
  const res = Stdlib__Array.init(length, (function (i) {
          const match = arr[i];
          if (match) {
            return match.v;
          } else {
            return missing_element(i, length);
          }
        }));
  check_same_length("to_array", a, length);
  return res;
}

function of_list(li) {
  const a = {
    length: 0,
    arr: []
  };
  Stdlib__List.iter((function (x) {
          add_last(a, x);
        }), li);
  return a;
}

function to_list(a) {
  const length = a.length;
  const arr = a.arr;
  const capacity = arr.length;
  if (length > capacity) {
    invalid_length(length, capacity);
  }
  let l = /* [] */0;
  for(let i = length - 1 | 0; i >= 0; --i){
    const match = arr[i];
    l = {
      hd: match ? match.v : missing_element(i, length),
      tl: l
    };
  }
  check_same_length("to_list", a, length);
  return l;
}

function of_seq(seq) {
  const init = {
    length: 0,
    arr: []
  };
  append_seq(init, seq);
  return init;
}

function to_seq(a) {
  const length = a.length;
  const arr = a.arr;
  const capacity = arr.length;
  if (length > capacity) {
    invalid_length(length, capacity);
  }
  const aux = function (i) {
    return function (param) {
      check_same_length("to_seq", a, length);
      if (i >= length) {
        return /* Nil */0;
      }
      const match = arr[i];
      const v = match ? match.v : missing_element(i, length);
      return /* Cons */{
              _0: v,
              _1: aux(i + 1 | 0)
            };
    };
  };
  return aux(0);
}

function to_seq_reentrant(a) {
  const aux = function (i) {
    return function (param) {
      if (i >= a.length) {
        return /* Nil */0;
      }
      const v = get(a, i);
      return /* Cons */{
              _0: v,
              _1: aux(i + 1 | 0)
            };
    };
  };
  return aux(0);
}

function to_seq_rev(a) {
  const length = a.length;
  const arr = a.arr;
  const capacity = arr.length;
  if (length > capacity) {
    invalid_length(length, capacity);
  }
  const aux = function (i) {
    return function (param) {
      check_same_length("to_seq_rev", a, length);
      if (i < 0) {
        return /* Nil */0;
      }
      const match = arr[i];
      const v = match ? match.v : missing_element(i, length);
      return /* Cons */{
              _0: v,
              _1: aux(i - 1 | 0)
            };
    };
  };
  return aux(length - 1 | 0);
}

function to_seq_rev_reentrant(a) {
  const aux = function (i) {
    return function (param) {
      if (i < 0) {
        return /* Nil */0;
      }
      if (i >= a.length) {
        return aux(a.length - 1 | 0)(undefined);
      }
      const v = get(a, i);
      return /* Cons */{
              _0: v,
              _1: aux(i - 1 | 0)
            };
    };
  };
  return aux(a.length - 1 | 0);
}

export {
  create ,
  make ,
  init ,
  get ,
  set ,
  length ,
  is_empty ,
  get_last ,
  find_last ,
  copy ,
  add_last ,
  append_array ,
  append_list ,
  append ,
  append_seq ,
  append_iter ,
  pop_last_opt ,
  pop_last ,
  remove_last ,
  truncate ,
  clear ,
  iter ,
  iteri ,
  map ,
  mapi ,
  fold_left ,
  fold_right ,
  exists ,
  for_all ,
  filter ,
  filter_map ,
  of_array ,
  to_array ,
  of_list ,
  to_list ,
  of_seq ,
  to_seq ,
  to_seq_reentrant ,
  to_seq_rev ,
  to_seq_rev_reentrant ,
  capacity ,
  ensure_capacity ,
  ensure_extra_capacity ,
  fit_capacity ,
  set_capacity ,
  reset ,
}
/* No side effect */
