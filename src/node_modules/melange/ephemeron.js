// Generated by Melange

import * as Caml_array from "melange.js/caml_array.js";
import * as Caml_js_exceptions from "melange.js/caml_js_exceptions.js";
import * as Caml_option from "melange.js/caml_option.js";
import * as CamlinternalLazy from "./camlinternalLazy.js";
import * as Curry from "melange.js/curry.js";
import * as Stdlib from "./stdlib.js";
import * as Stdlib__Array from "./array.js";
import * as Stdlib__Hashtbl from "./hashtbl.js";
import * as Stdlib__Int from "./int.js";
import * as Stdlib__List from "./list.js";
import * as Stdlib__Obj from "./obj.js";
import * as Stdlib__Random from "./random.js";
import * as Stdlib__Seq from "./seq.js";
import * as Stdlib__Sys from "./sys.js";

function set_key(t, k) {
  Stdlib__Obj.Ephemeron.set_key(t, 0, k);
}

function check_key(t) {
  return Stdlib__Obj.Ephemeron.check_key(t, 0);
}

function get_data(t) {
  return Stdlib__Obj.Ephemeron.get_data(t);
}

function make(key, data) {
  const eph = Stdlib__Obj.Ephemeron.create(1);
  Stdlib__Obj.Ephemeron.set_data(eph, data);
  set_key(eph, key);
  return eph;
}

function query(eph, key) {
  const k = Stdlib__Obj.Ephemeron.get_key(eph, 0);
  if (k !== undefined && Caml_option.valFromOption(k) === key) {
    return Stdlib__Obj.Ephemeron.get_data(eph);
  }
  
}

function MakeSeeded(H) {
  const create = function (k, d) {
    const c = Stdlib__Obj.Ephemeron.create(1);
    Stdlib__Obj.Ephemeron.set_data(c, d);
    set_key(c, k);
    return c;
  };
  const seeded_hash = H.seeded_hash;
  const equal = function (c, k) {
    const k$p = Stdlib__Obj.Ephemeron.get_key(c, 0);
    if (k$p !== undefined) {
      if (Curry._2(H.equal, k, Caml_option.valFromOption(k$p))) {
        return /* ETrue */0;
      } else {
        return /* EFalse */1;
      }
    } else {
      return /* EDead */2;
    }
  };
  const power_2_above = function (_x, n) {
    while(true) {
      const x = _x;
      if (x >= n) {
        return x;
      }
      if ((x << 1) > Stdlib__Sys.max_array_length) {
        return x;
      }
      _x = (x << 1);
      continue ;
    };
  };
  const prng = {
    LAZY_DONE: false,
    VAL: (function () {
        return Stdlib__Random.State.make_self_init(undefined);
      })
  };
  const create$1 = function (randomOpt, initial_size) {
    const random = randomOpt !== undefined ? randomOpt : Stdlib__Hashtbl.is_randomized(undefined);
    const s = power_2_above(16, initial_size);
    const seed = random ? Stdlib__Random.State.bits(CamlinternalLazy.force(prng)) : 0;
    return {
            size: 0,
            data: Caml_array.make(s, /* Empty */0),
            seed: seed,
            initial_size: s
          };
  };
  const clear = function (h) {
    h.size = 0;
    const len = h.data.length;
    for(let i = 0; i < len; ++i){
      Caml_array.set(h.data, i, /* Empty */0);
    }
  };
  const reset = function (h) {
    const len = h.data.length;
    if (len === h.initial_size) {
      return clear(h);
    } else {
      h.size = 0;
      h.data = Caml_array.make(h.initial_size, /* Empty */0);
      return ;
    }
  };
  const copy = function (h) {
    return {
            size: h.size,
            data: Stdlib__Array.copy(h.data),
            seed: h.seed,
            initial_size: h.initial_size
          };
  };
  const key_index = function (h, hkey) {
    return hkey & (h.data.length - 1 | 0);
  };
  const clean = function (h) {
    const do_bucket = function (_param) {
      while(true) {
        const param = _param;
        if (!param) {
          return /* Empty */0;
        }
        if (check_key(param._1)) {
          return /* Cons */{
                  _0: param._0,
                  _1: param._1,
                  _2: do_bucket(param._2)
                };
        }
        h.size = h.size - 1 | 0;
        _param = param._2;
        continue ;
      };
    };
    const d = h.data;
    for(let i = 0 ,i_finish = d.length; i < i_finish; ++i){
      Caml_array.set(d, i, do_bucket(Caml_array.get(d, i)));
    }
  };
  const resize = function (h) {
    const odata = h.data;
    const osize = odata.length;
    const nsize = (osize << 1);
    clean(h);
    if (!(nsize < Stdlib__Sys.max_array_length && h.size >= (osize >>> 1))) {
      return ;
    }
    const ndata = Caml_array.make(nsize, /* Empty */0);
    h.data = ndata;
    const insert_bucket = function (param) {
      if (!param) {
        return ;
      }
      const hkey = param._0;
      insert_bucket(param._2);
      const nidx = key_index(h, hkey);
      Caml_array.set(ndata, nidx, /* Cons */{
            _0: hkey,
            _1: param._1,
            _2: Caml_array.get(ndata, nidx)
          });
    };
    for(let i = 0; i < osize; ++i){
      insert_bucket(Caml_array.get(odata, i));
    }
  };
  const add = function (h, key, info) {
    const hkey = Curry._2(seeded_hash, h.seed, key);
    const i = key_index(h, hkey);
    const container = create(key, info);
    const bucket_2 = Caml_array.get(h.data, i);
    const bucket = /* Cons */{
      _0: hkey,
      _1: container,
      _2: bucket_2
    };
    Caml_array.set(h.data, i, bucket);
    h.size = h.size + 1 | 0;
    if (h.size > (h.data.length << 1)) {
      return resize(h);
    }
    
  };
  const remove = function (h, key) {
    const hkey = Curry._2(seeded_hash, h.seed, key);
    const remove_bucket = function (_param) {
      while(true) {
        const param = _param;
        if (!param) {
          return /* Empty */0;
        }
        const hk = param._0;
        if (hkey !== hk) {
          return /* Cons */{
                  _0: hk,
                  _1: param._1,
                  _2: remove_bucket(param._2)
                };
        }
        const next = param._2;
        const c = param._1;
        const match = equal(c, key);
        switch (match) {
          case /* ETrue */0 :
              h.size = h.size - 1 | 0;
              return next;
          case /* EFalse */1 :
              return /* Cons */{
                      _0: hk,
                      _1: c,
                      _2: remove_bucket(next)
                    };
          case /* EDead */2 :
              h.size = h.size - 1 | 0;
              _param = next;
              continue ;
          
        }
      };
    };
    const i = key_index(h, hkey);
    Caml_array.set(h.data, i, remove_bucket(Caml_array.get(h.data, i)));
  };
  const find = function (h, key) {
    const hkey = Curry._2(seeded_hash, h.seed, key);
    let _param = Caml_array.get(h.data, key_index(h, hkey));
    while(true) {
      const param = _param;
      if (param) {
        if (hkey === param._0) {
          const rest = param._2;
          const c = param._1;
          const match = equal(c, key);
          if (match) {
            _param = rest;
            continue ;
          }
          const d = get_data(c);
          if (d !== undefined) {
            return Caml_option.valFromOption(d);
          }
          _param = rest;
          continue ;
        }
        _param = param._2;
        continue ;
      }
      throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
                MEL_EXN_ID: Stdlib.Not_found
              });
    };
  };
  const find_opt = function (h, key) {
    const hkey = Curry._2(seeded_hash, h.seed, key);
    let _param = Caml_array.get(h.data, key_index(h, hkey));
    while(true) {
      const param = _param;
      if (!param) {
        return ;
      }
      if (hkey === param._0) {
        const rest = param._2;
        const c = param._1;
        const match = equal(c, key);
        if (match) {
          _param = rest;
          continue ;
        }
        const d = get_data(c);
        if (d !== undefined) {
          return d;
        }
        _param = rest;
        continue ;
      }
      _param = param._2;
      continue ;
    };
  };
  const find_all = function (h, key) {
    const hkey = Curry._2(seeded_hash, h.seed, key);
    const find_in_bucket = function (_param) {
      while(true) {
        const param = _param;
        if (!param) {
          return /* [] */0;
        }
        if (hkey === param._0) {
          const rest = param._2;
          const c = param._1;
          const match = equal(c, key);
          if (match) {
            _param = rest;
            continue ;
          }
          const d = get_data(c);
          if (d !== undefined) {
            return {
                    hd: Caml_option.valFromOption(d),
                    tl: find_in_bucket(rest)
                  };
          }
          _param = rest;
          continue ;
        }
        _param = param._2;
        continue ;
      };
    };
    return find_in_bucket(Caml_array.get(h.data, key_index(h, hkey)));
  };
  const replace = function (h, key, info) {
    const hkey = Curry._2(seeded_hash, h.seed, key);
    const i = key_index(h, hkey);
    const l = Caml_array.get(h.data, i);
    try {
      let _param = l;
      while(true) {
        const param = _param;
        if (param) {
          if (hkey === param._0) {
            const c = param._1;
            const match = equal(c, key);
            if (!match) {
              Stdlib__Obj.Ephemeron.unset_data(c);
              set_key(c, key);
              return Stdlib__Obj.Ephemeron.set_data(c, info);
            }
            _param = param._2;
            continue ;
          }
          _param = param._2;
          continue ;
        }
        throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
                  MEL_EXN_ID: Stdlib.Not_found
                });
      };
    }
    catch (raw_exn){
      const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
      if (exn.MEL_EXN_ID === Stdlib.Not_found) {
        const container = create(key, info);
        Caml_array.set(h.data, i, /* Cons */{
              _0: hkey,
              _1: container,
              _2: l
            });
        h.size = h.size + 1 | 0;
        if (h.size > (h.data.length << 1)) {
          return resize(h);
        } else {
          return ;
        }
      }
      throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
    }
  };
  const mem = function (h, key) {
    const hkey = Curry._2(seeded_hash, h.seed, key);
    let _param = Caml_array.get(h.data, key_index(h, hkey));
    while(true) {
      const param = _param;
      if (!param) {
        return false;
      }
      if (param._0 === hkey) {
        const match = equal(param._1, key);
        if (!match) {
          return true;
        }
        _param = param._2;
        continue ;
      }
      _param = param._2;
      continue ;
    };
  };
  const length = function (h) {
    return h.size;
  };
  const bucket_length = function (_accu, _param) {
    while(true) {
      const param = _param;
      const accu = _accu;
      if (!param) {
        return accu;
      }
      _param = param._2;
      _accu = accu + 1 | 0;
      continue ;
    };
  };
  const stats = function (h) {
    const mbl = Stdlib__Array.fold_left((function (m, b) {
            return Stdlib__Int.max(m, bucket_length(0, b));
          }), 0, h.data);
    const histo = Caml_array.make(mbl + 1 | 0, 0);
    Stdlib__Array.iter((function (b) {
            const l = bucket_length(0, b);
            Caml_array.set(histo, l, Caml_array.get(histo, l) + 1 | 0);
          }), h.data);
    return {
            num_bindings: h.size,
            num_buckets: h.data.length,
            max_bucket_length: mbl,
            bucket_histogram: histo
          };
  };
  const bucket_length_alive = function (_accu, _param) {
    while(true) {
      const param = _param;
      const accu = _accu;
      if (!param) {
        return accu;
      }
      if (check_key(param._1)) {
        _param = param._2;
        _accu = accu + 1 | 0;
        continue ;
      }
      _param = param._2;
      continue ;
    };
  };
  const stats_alive = function (h) {
    const size = {
      contents: 0
    };
    const mbl = Stdlib__Array.fold_left((function (m, b) {
            return Stdlib__Int.max(m, bucket_length_alive(0, b));
          }), 0, h.data);
    const histo = Caml_array.make(mbl + 1 | 0, 0);
    Stdlib__Array.iter((function (b) {
            const l = bucket_length_alive(0, b);
            size.contents = size.contents + l | 0;
            Caml_array.set(histo, l, Caml_array.get(histo, l) + 1 | 0);
          }), h.data);
    return {
            num_bindings: size.contents,
            num_buckets: h.data.length,
            max_bucket_length: mbl,
            bucket_histogram: histo
          };
  };
  const add_seq = function (tbl, i) {
    Stdlib__Seq.iter((function (param) {
            add(tbl, param[0], param[1]);
          }), i);
  };
  const replace_seq = function (tbl, i) {
    Stdlib__Seq.iter((function (param) {
            replace(tbl, param[0], param[1]);
          }), i);
  };
  const of_seq = function (i) {
    const tbl = create$1(undefined, 16);
    replace_seq(tbl, i);
    return tbl;
  };
  return {
          create: create$1,
          clear: clear,
          reset: reset,
          copy: copy,
          add: add,
          remove: remove,
          find: find,
          find_opt: find_opt,
          find_all: find_all,
          replace: replace,
          mem: mem,
          length: length,
          stats: stats,
          add_seq: add_seq,
          replace_seq: replace_seq,
          of_seq: of_seq,
          clean: clean,
          stats_alive: stats_alive
        };
}

function Make(H) {
  const equal = H.equal;
  const seeded_hash = function (_seed, x) {
    return Curry._1(H.hash, x);
  };
  const create = function (k, d) {
    const c = Stdlib__Obj.Ephemeron.create(1);
    Stdlib__Obj.Ephemeron.set_data(c, d);
    set_key(c, k);
    return c;
  };
  const equal$1 = function (c, k) {
    const k$p = Stdlib__Obj.Ephemeron.get_key(c, 0);
    if (k$p !== undefined) {
      if (Curry._2(equal, k, Caml_option.valFromOption(k$p))) {
        return /* ETrue */0;
      } else {
        return /* EFalse */1;
      }
    } else {
      return /* EDead */2;
    }
  };
  const power_2_above = function (_x, n) {
    while(true) {
      const x = _x;
      if (x >= n) {
        return x;
      }
      if ((x << 1) > Stdlib__Sys.max_array_length) {
        return x;
      }
      _x = (x << 1);
      continue ;
    };
  };
  const prng = {
    LAZY_DONE: false,
    VAL: (function () {
        return Stdlib__Random.State.make_self_init(undefined);
      })
  };
  const create$1 = function (randomOpt, initial_size) {
    const random = randomOpt !== undefined ? randomOpt : Stdlib__Hashtbl.is_randomized(undefined);
    const s = power_2_above(16, initial_size);
    const seed = random ? Stdlib__Random.State.bits(CamlinternalLazy.force(prng)) : 0;
    return {
            size: 0,
            data: Caml_array.make(s, /* Empty */0),
            seed: seed,
            initial_size: s
          };
  };
  const clear = function (h) {
    h.size = 0;
    const len = h.data.length;
    for(let i = 0; i < len; ++i){
      Caml_array.set(h.data, i, /* Empty */0);
    }
  };
  const reset = function (h) {
    const len = h.data.length;
    if (len === h.initial_size) {
      return clear(h);
    } else {
      h.size = 0;
      h.data = Caml_array.make(h.initial_size, /* Empty */0);
      return ;
    }
  };
  const copy = function (h) {
    return {
            size: h.size,
            data: Stdlib__Array.copy(h.data),
            seed: h.seed,
            initial_size: h.initial_size
          };
  };
  const key_index = function (h, hkey) {
    return hkey & (h.data.length - 1 | 0);
  };
  const clean = function (h) {
    const do_bucket = function (_param) {
      while(true) {
        const param = _param;
        if (!param) {
          return /* Empty */0;
        }
        if (check_key(param._1)) {
          return /* Cons */{
                  _0: param._0,
                  _1: param._1,
                  _2: do_bucket(param._2)
                };
        }
        h.size = h.size - 1 | 0;
        _param = param._2;
        continue ;
      };
    };
    const d = h.data;
    for(let i = 0 ,i_finish = d.length; i < i_finish; ++i){
      Caml_array.set(d, i, do_bucket(Caml_array.get(d, i)));
    }
  };
  const resize = function (h) {
    const odata = h.data;
    const osize = odata.length;
    const nsize = (osize << 1);
    clean(h);
    if (!(nsize < Stdlib__Sys.max_array_length && h.size >= (osize >>> 1))) {
      return ;
    }
    const ndata = Caml_array.make(nsize, /* Empty */0);
    h.data = ndata;
    const insert_bucket = function (param) {
      if (!param) {
        return ;
      }
      const hkey = param._0;
      insert_bucket(param._2);
      const nidx = key_index(h, hkey);
      Caml_array.set(ndata, nidx, /* Cons */{
            _0: hkey,
            _1: param._1,
            _2: Caml_array.get(ndata, nidx)
          });
    };
    for(let i = 0; i < osize; ++i){
      insert_bucket(Caml_array.get(odata, i));
    }
  };
  const add = function (h, key, info) {
    const hkey = seeded_hash(h.seed, key);
    const i = key_index(h, hkey);
    const container = create(key, info);
    const bucket_2 = Caml_array.get(h.data, i);
    const bucket = /* Cons */{
      _0: hkey,
      _1: container,
      _2: bucket_2
    };
    Caml_array.set(h.data, i, bucket);
    h.size = h.size + 1 | 0;
    if (h.size > (h.data.length << 1)) {
      return resize(h);
    }
    
  };
  const remove = function (h, key) {
    const hkey = seeded_hash(h.seed, key);
    const remove_bucket = function (_param) {
      while(true) {
        const param = _param;
        if (!param) {
          return /* Empty */0;
        }
        const hk = param._0;
        if (hkey !== hk) {
          return /* Cons */{
                  _0: hk,
                  _1: param._1,
                  _2: remove_bucket(param._2)
                };
        }
        const next = param._2;
        const c = param._1;
        const match = equal$1(c, key);
        switch (match) {
          case /* ETrue */0 :
              h.size = h.size - 1 | 0;
              return next;
          case /* EFalse */1 :
              return /* Cons */{
                      _0: hk,
                      _1: c,
                      _2: remove_bucket(next)
                    };
          case /* EDead */2 :
              h.size = h.size - 1 | 0;
              _param = next;
              continue ;
          
        }
      };
    };
    const i = key_index(h, hkey);
    Caml_array.set(h.data, i, remove_bucket(Caml_array.get(h.data, i)));
  };
  const find = function (h, key) {
    const hkey = seeded_hash(h.seed, key);
    let _param = Caml_array.get(h.data, key_index(h, hkey));
    while(true) {
      const param = _param;
      if (param) {
        if (hkey === param._0) {
          const rest = param._2;
          const c = param._1;
          const match = equal$1(c, key);
          if (match) {
            _param = rest;
            continue ;
          }
          const d = get_data(c);
          if (d !== undefined) {
            return Caml_option.valFromOption(d);
          }
          _param = rest;
          continue ;
        }
        _param = param._2;
        continue ;
      }
      throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
                MEL_EXN_ID: Stdlib.Not_found
              });
    };
  };
  const find_opt = function (h, key) {
    const hkey = seeded_hash(h.seed, key);
    let _param = Caml_array.get(h.data, key_index(h, hkey));
    while(true) {
      const param = _param;
      if (!param) {
        return ;
      }
      if (hkey === param._0) {
        const rest = param._2;
        const c = param._1;
        const match = equal$1(c, key);
        if (match) {
          _param = rest;
          continue ;
        }
        const d = get_data(c);
        if (d !== undefined) {
          return d;
        }
        _param = rest;
        continue ;
      }
      _param = param._2;
      continue ;
    };
  };
  const find_all = function (h, key) {
    const hkey = seeded_hash(h.seed, key);
    const find_in_bucket = function (_param) {
      while(true) {
        const param = _param;
        if (!param) {
          return /* [] */0;
        }
        if (hkey === param._0) {
          const rest = param._2;
          const c = param._1;
          const match = equal$1(c, key);
          if (match) {
            _param = rest;
            continue ;
          }
          const d = get_data(c);
          if (d !== undefined) {
            return {
                    hd: Caml_option.valFromOption(d),
                    tl: find_in_bucket(rest)
                  };
          }
          _param = rest;
          continue ;
        }
        _param = param._2;
        continue ;
      };
    };
    return find_in_bucket(Caml_array.get(h.data, key_index(h, hkey)));
  };
  const replace = function (h, key, info) {
    const hkey = seeded_hash(h.seed, key);
    const i = key_index(h, hkey);
    const l = Caml_array.get(h.data, i);
    try {
      let _param = l;
      while(true) {
        const param = _param;
        if (param) {
          if (hkey === param._0) {
            const c = param._1;
            const match = equal$1(c, key);
            if (!match) {
              Stdlib__Obj.Ephemeron.unset_data(c);
              set_key(c, key);
              return Stdlib__Obj.Ephemeron.set_data(c, info);
            }
            _param = param._2;
            continue ;
          }
          _param = param._2;
          continue ;
        }
        throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
                  MEL_EXN_ID: Stdlib.Not_found
                });
      };
    }
    catch (raw_exn){
      const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
      if (exn.MEL_EXN_ID === Stdlib.Not_found) {
        const container = create(key, info);
        Caml_array.set(h.data, i, /* Cons */{
              _0: hkey,
              _1: container,
              _2: l
            });
        h.size = h.size + 1 | 0;
        if (h.size > (h.data.length << 1)) {
          return resize(h);
        } else {
          return ;
        }
      }
      throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
    }
  };
  const mem = function (h, key) {
    const hkey = seeded_hash(h.seed, key);
    let _param = Caml_array.get(h.data, key_index(h, hkey));
    while(true) {
      const param = _param;
      if (!param) {
        return false;
      }
      if (param._0 === hkey) {
        const match = equal$1(param._1, key);
        if (!match) {
          return true;
        }
        _param = param._2;
        continue ;
      }
      _param = param._2;
      continue ;
    };
  };
  const length = function (h) {
    return h.size;
  };
  const bucket_length = function (_accu, _param) {
    while(true) {
      const param = _param;
      const accu = _accu;
      if (!param) {
        return accu;
      }
      _param = param._2;
      _accu = accu + 1 | 0;
      continue ;
    };
  };
  const stats = function (h) {
    const mbl = Stdlib__Array.fold_left((function (m, b) {
            return Stdlib__Int.max(m, bucket_length(0, b));
          }), 0, h.data);
    const histo = Caml_array.make(mbl + 1 | 0, 0);
    Stdlib__Array.iter((function (b) {
            const l = bucket_length(0, b);
            Caml_array.set(histo, l, Caml_array.get(histo, l) + 1 | 0);
          }), h.data);
    return {
            num_bindings: h.size,
            num_buckets: h.data.length,
            max_bucket_length: mbl,
            bucket_histogram: histo
          };
  };
  const bucket_length_alive = function (_accu, _param) {
    while(true) {
      const param = _param;
      const accu = _accu;
      if (!param) {
        return accu;
      }
      if (check_key(param._1)) {
        _param = param._2;
        _accu = accu + 1 | 0;
        continue ;
      }
      _param = param._2;
      continue ;
    };
  };
  const stats_alive = function (h) {
    const size = {
      contents: 0
    };
    const mbl = Stdlib__Array.fold_left((function (m, b) {
            return Stdlib__Int.max(m, bucket_length_alive(0, b));
          }), 0, h.data);
    const histo = Caml_array.make(mbl + 1 | 0, 0);
    Stdlib__Array.iter((function (b) {
            const l = bucket_length_alive(0, b);
            size.contents = size.contents + l | 0;
            Caml_array.set(histo, l, Caml_array.get(histo, l) + 1 | 0);
          }), h.data);
    return {
            num_bindings: size.contents,
            num_buckets: h.data.length,
            max_bucket_length: mbl,
            bucket_histogram: histo
          };
  };
  const add_seq = function (tbl, i) {
    Stdlib__Seq.iter((function (param) {
            add(tbl, param[0], param[1]);
          }), i);
  };
  const replace_seq = function (tbl, i) {
    Stdlib__Seq.iter((function (param) {
            replace(tbl, param[0], param[1]);
          }), i);
  };
  const create$2 = function (sz) {
    return create$1(false, sz);
  };
  const of_seq = function (i) {
    const tbl = create$1(false, 16);
    replace_seq(tbl, i);
    return tbl;
  };
  return {
          create: create$2,
          clear: clear,
          reset: reset,
          copy: copy,
          add: add,
          remove: remove,
          find: find,
          find_opt: find_opt,
          find_all: find_all,
          replace: replace,
          mem: mem,
          length: length,
          stats: stats,
          add_seq: add_seq,
          replace_seq: replace_seq,
          of_seq: of_seq,
          clean: clean,
          stats_alive: stats_alive
        };
}

function make$1(param) {
  return {
          contents: /* [] */0
        };
}

function add(b, k, d) {
  b.contents = {
    hd: make(k, d),
    tl: b.contents
  };
}

function test_key(k, e) {
  const x = Stdlib__Obj.Ephemeron.get_key(e, 0);
  if (x !== undefined) {
    return Caml_option.valFromOption(x) === k;
  } else {
    return false;
  }
}

function remove(b, k) {
  let _l = b.contents;
  let _acc = /* [] */0;
  while(true) {
    const acc = _acc;
    const l = _l;
    if (!l) {
      return ;
    }
    const h = l.hd;
    if (test_key(k, h)) {
      b.contents = Stdlib__List.rev_append(acc, l.tl);
      return ;
    }
    _acc = {
      hd: h,
      tl: acc
    };
    _l = l.tl;
    continue ;
  };
}

function find(b, k) {
  const e = Stdlib__List.find_opt((function (param) {
          return test_key(k, param);
        }), b.contents);
  if (e !== undefined) {
    return Stdlib__Obj.Ephemeron.get_data(Caml_option.valFromOption(e));
  }
  
}

function length(b) {
  return Stdlib__List.length(b.contents);
}

function clear(b) {
  b.contents = /* [] */0;
}

function set_key1(t, k) {
  Stdlib__Obj.Ephemeron.set_key(t, 0, k);
}

function set_key2(t, k) {
  Stdlib__Obj.Ephemeron.set_key(t, 1, k);
}

function get_data$1(t) {
  return Stdlib__Obj.Ephemeron.get_data(t);
}

function make$2(key1, key2, data) {
  const eph = Stdlib__Obj.Ephemeron.create(2);
  Stdlib__Obj.Ephemeron.set_data(eph, data);
  set_key1(eph, key1);
  set_key2(eph, key2);
  return eph;
}

function query$1(eph, key1, key2) {
  const k = Stdlib__Obj.Ephemeron.get_key(eph, 0);
  if (k === undefined) {
    return ;
  }
  if (Caml_option.valFromOption(k) !== key1) {
    return ;
  }
  const k$1 = Stdlib__Obj.Ephemeron.get_key(eph, 1);
  if (k$1 !== undefined && Caml_option.valFromOption(k$1) === key2) {
    return Stdlib__Obj.Ephemeron.get_data(eph);
  }
  
}

function MakeSeeded$1(H1, H2) {
  const create = function (param, d) {
    const c = Stdlib__Obj.Ephemeron.create(2);
    Stdlib__Obj.Ephemeron.set_data(c, d);
    set_key1(c, param[0]);
    set_key2(c, param[1]);
    return c;
  };
  const seeded_hash = function (seed, param) {
    return Curry._2(H1.seeded_hash, seed, param[0]) + Math.imul(Curry._2(H2.seeded_hash, seed, param[1]), 65599) | 0;
  };
  const equal = function (c, param) {
    const match = Stdlib__Obj.Ephemeron.get_key(c, 0);
    const match$1 = Stdlib__Obj.Ephemeron.get_key(c, 1);
    if (match !== undefined && match$1 !== undefined) {
      if (Curry._2(H1.equal, param[0], Caml_option.valFromOption(match)) && Curry._2(H2.equal, param[1], Caml_option.valFromOption(match$1))) {
        return /* ETrue */0;
      } else {
        return /* EFalse */1;
      }
    } else {
      return /* EDead */2;
    }
  };
  const check_key = function (c) {
    if (Stdlib__Obj.Ephemeron.check_key(c, 0)) {
      return Stdlib__Obj.Ephemeron.check_key(c, 1);
    } else {
      return false;
    }
  };
  const power_2_above = function (_x, n) {
    while(true) {
      const x = _x;
      if (x >= n) {
        return x;
      }
      if ((x << 1) > Stdlib__Sys.max_array_length) {
        return x;
      }
      _x = (x << 1);
      continue ;
    };
  };
  const prng = {
    LAZY_DONE: false,
    VAL: (function () {
        return Stdlib__Random.State.make_self_init(undefined);
      })
  };
  const create$1 = function (randomOpt, initial_size) {
    const random = randomOpt !== undefined ? randomOpt : Stdlib__Hashtbl.is_randomized(undefined);
    const s = power_2_above(16, initial_size);
    const seed = random ? Stdlib__Random.State.bits(CamlinternalLazy.force(prng)) : 0;
    return {
            size: 0,
            data: Caml_array.make(s, /* Empty */0),
            seed: seed,
            initial_size: s
          };
  };
  const clear = function (h) {
    h.size = 0;
    const len = h.data.length;
    for(let i = 0; i < len; ++i){
      Caml_array.set(h.data, i, /* Empty */0);
    }
  };
  const reset = function (h) {
    const len = h.data.length;
    if (len === h.initial_size) {
      return clear(h);
    } else {
      h.size = 0;
      h.data = Caml_array.make(h.initial_size, /* Empty */0);
      return ;
    }
  };
  const copy = function (h) {
    return {
            size: h.size,
            data: Stdlib__Array.copy(h.data),
            seed: h.seed,
            initial_size: h.initial_size
          };
  };
  const key_index = function (h, hkey) {
    return hkey & (h.data.length - 1 | 0);
  };
  const clean = function (h) {
    const do_bucket = function (_param) {
      while(true) {
        const param = _param;
        if (!param) {
          return /* Empty */0;
        }
        if (check_key(param._1)) {
          return /* Cons */{
                  _0: param._0,
                  _1: param._1,
                  _2: do_bucket(param._2)
                };
        }
        h.size = h.size - 1 | 0;
        _param = param._2;
        continue ;
      };
    };
    const d = h.data;
    for(let i = 0 ,i_finish = d.length; i < i_finish; ++i){
      Caml_array.set(d, i, do_bucket(Caml_array.get(d, i)));
    }
  };
  const resize = function (h) {
    const odata = h.data;
    const osize = odata.length;
    const nsize = (osize << 1);
    clean(h);
    if (!(nsize < Stdlib__Sys.max_array_length && h.size >= (osize >>> 1))) {
      return ;
    }
    const ndata = Caml_array.make(nsize, /* Empty */0);
    h.data = ndata;
    const insert_bucket = function (param) {
      if (!param) {
        return ;
      }
      const hkey = param._0;
      insert_bucket(param._2);
      const nidx = key_index(h, hkey);
      Caml_array.set(ndata, nidx, /* Cons */{
            _0: hkey,
            _1: param._1,
            _2: Caml_array.get(ndata, nidx)
          });
    };
    for(let i = 0; i < osize; ++i){
      insert_bucket(Caml_array.get(odata, i));
    }
  };
  const add = function (h, key, info) {
    const hkey = seeded_hash(h.seed, key);
    const i = key_index(h, hkey);
    const container = create(key, info);
    const bucket_2 = Caml_array.get(h.data, i);
    const bucket = /* Cons */{
      _0: hkey,
      _1: container,
      _2: bucket_2
    };
    Caml_array.set(h.data, i, bucket);
    h.size = h.size + 1 | 0;
    if (h.size > (h.data.length << 1)) {
      return resize(h);
    }
    
  };
  const remove = function (h, key) {
    const hkey = seeded_hash(h.seed, key);
    const remove_bucket = function (_param) {
      while(true) {
        const param = _param;
        if (!param) {
          return /* Empty */0;
        }
        const hk = param._0;
        if (hkey !== hk) {
          return /* Cons */{
                  _0: hk,
                  _1: param._1,
                  _2: remove_bucket(param._2)
                };
        }
        const next = param._2;
        const c = param._1;
        const match = equal(c, key);
        switch (match) {
          case /* ETrue */0 :
              h.size = h.size - 1 | 0;
              return next;
          case /* EFalse */1 :
              return /* Cons */{
                      _0: hk,
                      _1: c,
                      _2: remove_bucket(next)
                    };
          case /* EDead */2 :
              h.size = h.size - 1 | 0;
              _param = next;
              continue ;
          
        }
      };
    };
    const i = key_index(h, hkey);
    Caml_array.set(h.data, i, remove_bucket(Caml_array.get(h.data, i)));
  };
  const find = function (h, key) {
    const hkey = seeded_hash(h.seed, key);
    let _param = Caml_array.get(h.data, key_index(h, hkey));
    while(true) {
      const param = _param;
      if (param) {
        if (hkey === param._0) {
          const rest = param._2;
          const c = param._1;
          const match = equal(c, key);
          if (match) {
            _param = rest;
            continue ;
          }
          const d = get_data$1(c);
          if (d !== undefined) {
            return Caml_option.valFromOption(d);
          }
          _param = rest;
          continue ;
        }
        _param = param._2;
        continue ;
      }
      throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
                MEL_EXN_ID: Stdlib.Not_found
              });
    };
  };
  const find_opt = function (h, key) {
    const hkey = seeded_hash(h.seed, key);
    let _param = Caml_array.get(h.data, key_index(h, hkey));
    while(true) {
      const param = _param;
      if (!param) {
        return ;
      }
      if (hkey === param._0) {
        const rest = param._2;
        const c = param._1;
        const match = equal(c, key);
        if (match) {
          _param = rest;
          continue ;
        }
        const d = get_data$1(c);
        if (d !== undefined) {
          return d;
        }
        _param = rest;
        continue ;
      }
      _param = param._2;
      continue ;
    };
  };
  const find_all = function (h, key) {
    const hkey = seeded_hash(h.seed, key);
    const find_in_bucket = function (_param) {
      while(true) {
        const param = _param;
        if (!param) {
          return /* [] */0;
        }
        if (hkey === param._0) {
          const rest = param._2;
          const c = param._1;
          const match = equal(c, key);
          if (match) {
            _param = rest;
            continue ;
          }
          const d = get_data$1(c);
          if (d !== undefined) {
            return {
                    hd: Caml_option.valFromOption(d),
                    tl: find_in_bucket(rest)
                  };
          }
          _param = rest;
          continue ;
        }
        _param = param._2;
        continue ;
      };
    };
    return find_in_bucket(Caml_array.get(h.data, key_index(h, hkey)));
  };
  const replace = function (h, key, info) {
    const hkey = seeded_hash(h.seed, key);
    const i = key_index(h, hkey);
    const l = Caml_array.get(h.data, i);
    try {
      let _param = l;
      while(true) {
        const param = _param;
        if (param) {
          if (hkey === param._0) {
            const c = param._1;
            const match = equal(c, key);
            if (!match) {
              Stdlib__Obj.Ephemeron.unset_data(c);
              set_key1(c, key[0]);
              set_key2(c, key[1]);
              return Stdlib__Obj.Ephemeron.set_data(c, info);
            }
            _param = param._2;
            continue ;
          }
          _param = param._2;
          continue ;
        }
        throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
                  MEL_EXN_ID: Stdlib.Not_found
                });
      };
    }
    catch (raw_exn){
      const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
      if (exn.MEL_EXN_ID === Stdlib.Not_found) {
        const container = create(key, info);
        Caml_array.set(h.data, i, /* Cons */{
              _0: hkey,
              _1: container,
              _2: l
            });
        h.size = h.size + 1 | 0;
        if (h.size > (h.data.length << 1)) {
          return resize(h);
        } else {
          return ;
        }
      }
      throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
    }
  };
  const mem = function (h, key) {
    const hkey = seeded_hash(h.seed, key);
    let _param = Caml_array.get(h.data, key_index(h, hkey));
    while(true) {
      const param = _param;
      if (!param) {
        return false;
      }
      if (param._0 === hkey) {
        const match = equal(param._1, key);
        if (!match) {
          return true;
        }
        _param = param._2;
        continue ;
      }
      _param = param._2;
      continue ;
    };
  };
  const length = function (h) {
    return h.size;
  };
  const bucket_length = function (_accu, _param) {
    while(true) {
      const param = _param;
      const accu = _accu;
      if (!param) {
        return accu;
      }
      _param = param._2;
      _accu = accu + 1 | 0;
      continue ;
    };
  };
  const stats = function (h) {
    const mbl = Stdlib__Array.fold_left((function (m, b) {
            return Stdlib__Int.max(m, bucket_length(0, b));
          }), 0, h.data);
    const histo = Caml_array.make(mbl + 1 | 0, 0);
    Stdlib__Array.iter((function (b) {
            const l = bucket_length(0, b);
            Caml_array.set(histo, l, Caml_array.get(histo, l) + 1 | 0);
          }), h.data);
    return {
            num_bindings: h.size,
            num_buckets: h.data.length,
            max_bucket_length: mbl,
            bucket_histogram: histo
          };
  };
  const bucket_length_alive = function (_accu, _param) {
    while(true) {
      const param = _param;
      const accu = _accu;
      if (!param) {
        return accu;
      }
      if (check_key(param._1)) {
        _param = param._2;
        _accu = accu + 1 | 0;
        continue ;
      }
      _param = param._2;
      continue ;
    };
  };
  const stats_alive = function (h) {
    const size = {
      contents: 0
    };
    const mbl = Stdlib__Array.fold_left((function (m, b) {
            return Stdlib__Int.max(m, bucket_length_alive(0, b));
          }), 0, h.data);
    const histo = Caml_array.make(mbl + 1 | 0, 0);
    Stdlib__Array.iter((function (b) {
            const l = bucket_length_alive(0, b);
            size.contents = size.contents + l | 0;
            Caml_array.set(histo, l, Caml_array.get(histo, l) + 1 | 0);
          }), h.data);
    return {
            num_bindings: size.contents,
            num_buckets: h.data.length,
            max_bucket_length: mbl,
            bucket_histogram: histo
          };
  };
  const add_seq = function (tbl, i) {
    Stdlib__Seq.iter((function (param) {
            add(tbl, param[0], param[1]);
          }), i);
  };
  const replace_seq = function (tbl, i) {
    Stdlib__Seq.iter((function (param) {
            replace(tbl, param[0], param[1]);
          }), i);
  };
  const of_seq = function (i) {
    const tbl = create$1(undefined, 16);
    replace_seq(tbl, i);
    return tbl;
  };
  return {
          create: create$1,
          clear: clear,
          reset: reset,
          copy: copy,
          add: add,
          remove: remove,
          find: find,
          find_opt: find_opt,
          find_all: find_all,
          replace: replace,
          mem: mem,
          length: length,
          stats: stats,
          add_seq: add_seq,
          replace_seq: replace_seq,
          of_seq: of_seq,
          clean: clean,
          stats_alive: stats_alive
        };
}

function Make$1(H1, H2) {
  const equal = H2.equal;
  const equal$1 = H1.equal;
  const create = function (param, d) {
    const c = Stdlib__Obj.Ephemeron.create(2);
    Stdlib__Obj.Ephemeron.set_data(c, d);
    set_key1(c, param[0]);
    set_key2(c, param[1]);
    return c;
  };
  const seeded_hash = function (seed, param) {
    return Curry._1(H1.hash, param[0]) + Math.imul(Curry._1(H2.hash, param[1]), 65599) | 0;
  };
  const equal$2 = function (c, param) {
    const match = Stdlib__Obj.Ephemeron.get_key(c, 0);
    const match$1 = Stdlib__Obj.Ephemeron.get_key(c, 1);
    if (match !== undefined && match$1 !== undefined) {
      if (Curry._2(equal$1, param[0], Caml_option.valFromOption(match)) && Curry._2(equal, param[1], Caml_option.valFromOption(match$1))) {
        return /* ETrue */0;
      } else {
        return /* EFalse */1;
      }
    } else {
      return /* EDead */2;
    }
  };
  const check_key = function (c) {
    if (Stdlib__Obj.Ephemeron.check_key(c, 0)) {
      return Stdlib__Obj.Ephemeron.check_key(c, 1);
    } else {
      return false;
    }
  };
  const power_2_above = function (_x, n) {
    while(true) {
      const x = _x;
      if (x >= n) {
        return x;
      }
      if ((x << 1) > Stdlib__Sys.max_array_length) {
        return x;
      }
      _x = (x << 1);
      continue ;
    };
  };
  const prng = {
    LAZY_DONE: false,
    VAL: (function () {
        return Stdlib__Random.State.make_self_init(undefined);
      })
  };
  const create$1 = function (randomOpt, initial_size) {
    const random = randomOpt !== undefined ? randomOpt : Stdlib__Hashtbl.is_randomized(undefined);
    const s = power_2_above(16, initial_size);
    const seed = random ? Stdlib__Random.State.bits(CamlinternalLazy.force(prng)) : 0;
    return {
            size: 0,
            data: Caml_array.make(s, /* Empty */0),
            seed: seed,
            initial_size: s
          };
  };
  const clear = function (h) {
    h.size = 0;
    const len = h.data.length;
    for(let i = 0; i < len; ++i){
      Caml_array.set(h.data, i, /* Empty */0);
    }
  };
  const reset = function (h) {
    const len = h.data.length;
    if (len === h.initial_size) {
      return clear(h);
    } else {
      h.size = 0;
      h.data = Caml_array.make(h.initial_size, /* Empty */0);
      return ;
    }
  };
  const copy = function (h) {
    return {
            size: h.size,
            data: Stdlib__Array.copy(h.data),
            seed: h.seed,
            initial_size: h.initial_size
          };
  };
  const key_index = function (h, hkey) {
    return hkey & (h.data.length - 1 | 0);
  };
  const clean = function (h) {
    const do_bucket = function (_param) {
      while(true) {
        const param = _param;
        if (!param) {
          return /* Empty */0;
        }
        if (check_key(param._1)) {
          return /* Cons */{
                  _0: param._0,
                  _1: param._1,
                  _2: do_bucket(param._2)
                };
        }
        h.size = h.size - 1 | 0;
        _param = param._2;
        continue ;
      };
    };
    const d = h.data;
    for(let i = 0 ,i_finish = d.length; i < i_finish; ++i){
      Caml_array.set(d, i, do_bucket(Caml_array.get(d, i)));
    }
  };
  const resize = function (h) {
    const odata = h.data;
    const osize = odata.length;
    const nsize = (osize << 1);
    clean(h);
    if (!(nsize < Stdlib__Sys.max_array_length && h.size >= (osize >>> 1))) {
      return ;
    }
    const ndata = Caml_array.make(nsize, /* Empty */0);
    h.data = ndata;
    const insert_bucket = function (param) {
      if (!param) {
        return ;
      }
      const hkey = param._0;
      insert_bucket(param._2);
      const nidx = key_index(h, hkey);
      Caml_array.set(ndata, nidx, /* Cons */{
            _0: hkey,
            _1: param._1,
            _2: Caml_array.get(ndata, nidx)
          });
    };
    for(let i = 0; i < osize; ++i){
      insert_bucket(Caml_array.get(odata, i));
    }
  };
  const add = function (h, key, info) {
    const hkey = seeded_hash(h.seed, key);
    const i = key_index(h, hkey);
    const container = create(key, info);
    const bucket_2 = Caml_array.get(h.data, i);
    const bucket = /* Cons */{
      _0: hkey,
      _1: container,
      _2: bucket_2
    };
    Caml_array.set(h.data, i, bucket);
    h.size = h.size + 1 | 0;
    if (h.size > (h.data.length << 1)) {
      return resize(h);
    }
    
  };
  const remove = function (h, key) {
    const hkey = seeded_hash(h.seed, key);
    const remove_bucket = function (_param) {
      while(true) {
        const param = _param;
        if (!param) {
          return /* Empty */0;
        }
        const hk = param._0;
        if (hkey !== hk) {
          return /* Cons */{
                  _0: hk,
                  _1: param._1,
                  _2: remove_bucket(param._2)
                };
        }
        const next = param._2;
        const c = param._1;
        const match = equal$2(c, key);
        switch (match) {
          case /* ETrue */0 :
              h.size = h.size - 1 | 0;
              return next;
          case /* EFalse */1 :
              return /* Cons */{
                      _0: hk,
                      _1: c,
                      _2: remove_bucket(next)
                    };
          case /* EDead */2 :
              h.size = h.size - 1 | 0;
              _param = next;
              continue ;
          
        }
      };
    };
    const i = key_index(h, hkey);
    Caml_array.set(h.data, i, remove_bucket(Caml_array.get(h.data, i)));
  };
  const find = function (h, key) {
    const hkey = seeded_hash(h.seed, key);
    let _param = Caml_array.get(h.data, key_index(h, hkey));
    while(true) {
      const param = _param;
      if (param) {
        if (hkey === param._0) {
          const rest = param._2;
          const c = param._1;
          const match = equal$2(c, key);
          if (match) {
            _param = rest;
            continue ;
          }
          const d = get_data$1(c);
          if (d !== undefined) {
            return Caml_option.valFromOption(d);
          }
          _param = rest;
          continue ;
        }
        _param = param._2;
        continue ;
      }
      throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
                MEL_EXN_ID: Stdlib.Not_found
              });
    };
  };
  const find_opt = function (h, key) {
    const hkey = seeded_hash(h.seed, key);
    let _param = Caml_array.get(h.data, key_index(h, hkey));
    while(true) {
      const param = _param;
      if (!param) {
        return ;
      }
      if (hkey === param._0) {
        const rest = param._2;
        const c = param._1;
        const match = equal$2(c, key);
        if (match) {
          _param = rest;
          continue ;
        }
        const d = get_data$1(c);
        if (d !== undefined) {
          return d;
        }
        _param = rest;
        continue ;
      }
      _param = param._2;
      continue ;
    };
  };
  const find_all = function (h, key) {
    const hkey = seeded_hash(h.seed, key);
    const find_in_bucket = function (_param) {
      while(true) {
        const param = _param;
        if (!param) {
          return /* [] */0;
        }
        if (hkey === param._0) {
          const rest = param._2;
          const c = param._1;
          const match = equal$2(c, key);
          if (match) {
            _param = rest;
            continue ;
          }
          const d = get_data$1(c);
          if (d !== undefined) {
            return {
                    hd: Caml_option.valFromOption(d),
                    tl: find_in_bucket(rest)
                  };
          }
          _param = rest;
          continue ;
        }
        _param = param._2;
        continue ;
      };
    };
    return find_in_bucket(Caml_array.get(h.data, key_index(h, hkey)));
  };
  const replace = function (h, key, info) {
    const hkey = seeded_hash(h.seed, key);
    const i = key_index(h, hkey);
    const l = Caml_array.get(h.data, i);
    try {
      let _param = l;
      while(true) {
        const param = _param;
        if (param) {
          if (hkey === param._0) {
            const c = param._1;
            const match = equal$2(c, key);
            if (!match) {
              Stdlib__Obj.Ephemeron.unset_data(c);
              set_key1(c, key[0]);
              set_key2(c, key[1]);
              return Stdlib__Obj.Ephemeron.set_data(c, info);
            }
            _param = param._2;
            continue ;
          }
          _param = param._2;
          continue ;
        }
        throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
                  MEL_EXN_ID: Stdlib.Not_found
                });
      };
    }
    catch (raw_exn){
      const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
      if (exn.MEL_EXN_ID === Stdlib.Not_found) {
        const container = create(key, info);
        Caml_array.set(h.data, i, /* Cons */{
              _0: hkey,
              _1: container,
              _2: l
            });
        h.size = h.size + 1 | 0;
        if (h.size > (h.data.length << 1)) {
          return resize(h);
        } else {
          return ;
        }
      }
      throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
    }
  };
  const mem = function (h, key) {
    const hkey = seeded_hash(h.seed, key);
    let _param = Caml_array.get(h.data, key_index(h, hkey));
    while(true) {
      const param = _param;
      if (!param) {
        return false;
      }
      if (param._0 === hkey) {
        const match = equal$2(param._1, key);
        if (!match) {
          return true;
        }
        _param = param._2;
        continue ;
      }
      _param = param._2;
      continue ;
    };
  };
  const length = function (h) {
    return h.size;
  };
  const bucket_length = function (_accu, _param) {
    while(true) {
      const param = _param;
      const accu = _accu;
      if (!param) {
        return accu;
      }
      _param = param._2;
      _accu = accu + 1 | 0;
      continue ;
    };
  };
  const stats = function (h) {
    const mbl = Stdlib__Array.fold_left((function (m, b) {
            return Stdlib__Int.max(m, bucket_length(0, b));
          }), 0, h.data);
    const histo = Caml_array.make(mbl + 1 | 0, 0);
    Stdlib__Array.iter((function (b) {
            const l = bucket_length(0, b);
            Caml_array.set(histo, l, Caml_array.get(histo, l) + 1 | 0);
          }), h.data);
    return {
            num_bindings: h.size,
            num_buckets: h.data.length,
            max_bucket_length: mbl,
            bucket_histogram: histo
          };
  };
  const bucket_length_alive = function (_accu, _param) {
    while(true) {
      const param = _param;
      const accu = _accu;
      if (!param) {
        return accu;
      }
      if (check_key(param._1)) {
        _param = param._2;
        _accu = accu + 1 | 0;
        continue ;
      }
      _param = param._2;
      continue ;
    };
  };
  const stats_alive = function (h) {
    const size = {
      contents: 0
    };
    const mbl = Stdlib__Array.fold_left((function (m, b) {
            return Stdlib__Int.max(m, bucket_length_alive(0, b));
          }), 0, h.data);
    const histo = Caml_array.make(mbl + 1 | 0, 0);
    Stdlib__Array.iter((function (b) {
            const l = bucket_length_alive(0, b);
            size.contents = size.contents + l | 0;
            Caml_array.set(histo, l, Caml_array.get(histo, l) + 1 | 0);
          }), h.data);
    return {
            num_bindings: size.contents,
            num_buckets: h.data.length,
            max_bucket_length: mbl,
            bucket_histogram: histo
          };
  };
  const add_seq = function (tbl, i) {
    Stdlib__Seq.iter((function (param) {
            add(tbl, param[0], param[1]);
          }), i);
  };
  const replace_seq = function (tbl, i) {
    Stdlib__Seq.iter((function (param) {
            replace(tbl, param[0], param[1]);
          }), i);
  };
  const create$2 = function (sz) {
    return create$1(false, sz);
  };
  const of_seq = function (i) {
    const tbl = create$1(false, 16);
    replace_seq(tbl, i);
    return tbl;
  };
  return {
          create: create$2,
          clear: clear,
          reset: reset,
          copy: copy,
          add: add,
          remove: remove,
          find: find,
          find_opt: find_opt,
          find_all: find_all,
          replace: replace,
          mem: mem,
          length: length,
          stats: stats,
          add_seq: add_seq,
          replace_seq: replace_seq,
          of_seq: of_seq,
          clean: clean,
          stats_alive: stats_alive
        };
}

function make$3(param) {
  return {
          contents: /* [] */0
        };
}

function add$1(b, k1, k2, d) {
  b.contents = {
    hd: make$2(k1, k2, d),
    tl: b.contents
  };
}

function test_keys(k1, k2, e) {
  const match = Stdlib__Obj.Ephemeron.get_key(e, 0);
  const match$1 = Stdlib__Obj.Ephemeron.get_key(e, 1);
  if (match !== undefined && match$1 !== undefined && Caml_option.valFromOption(match) === k1) {
    return Caml_option.valFromOption(match$1) === k2;
  } else {
    return false;
  }
}

function remove$1(b, k1, k2) {
  let _l = b.contents;
  let _acc = /* [] */0;
  while(true) {
    const acc = _acc;
    const l = _l;
    if (!l) {
      return ;
    }
    const h = l.hd;
    if (test_keys(k1, k2, h)) {
      b.contents = Stdlib__List.rev_append(acc, l.tl);
      return ;
    }
    _acc = {
      hd: h,
      tl: acc
    };
    _l = l.tl;
    continue ;
  };
}

function find$1(b, k1, k2) {
  const e = Stdlib__List.find_opt((function (param) {
          return test_keys(k1, k2, param);
        }), b.contents);
  if (e !== undefined) {
    return Stdlib__Obj.Ephemeron.get_data(Caml_option.valFromOption(e));
  }
  
}

function length$1(b) {
  return Stdlib__List.length(b.contents);
}

function clear$1(b) {
  b.contents = /* [] */0;
}

function set_key$1(t, n, k) {
  Stdlib__Obj.Ephemeron.set_key(t, n, k);
}

function get_data$2(t) {
  return Stdlib__Obj.Ephemeron.get_data(t);
}

function make$4(keys, data) {
  const l = keys.length;
  const eph = Stdlib__Obj.Ephemeron.create(l);
  Stdlib__Obj.Ephemeron.set_data(eph, data);
  for(let i = 0; i < l; ++i){
    set_key$1(eph, i, Caml_array.get(keys, i));
  }
  return eph;
}

function query$2(eph, keys) {
  const l = Stdlib__Obj.Ephemeron.length(eph);
  try {
    if (l !== keys.length) {
      throw new Caml_js_exceptions.MelangeError(Stdlib.Exit, {
                MEL_EXN_ID: Stdlib.Exit
              });
    }
    for(let i = 0; i < l; ++i){
      const k = Stdlib__Obj.Ephemeron.get_key(eph, i);
      if (k !== undefined) {
        if (Caml_option.valFromOption(k) !== Caml_array.get(keys, i)) {
          throw new Caml_js_exceptions.MelangeError(Stdlib.Exit, {
                    MEL_EXN_ID: Stdlib.Exit
                  });
        }
        
      } else {
        throw new Caml_js_exceptions.MelangeError(Stdlib.Exit, {
                  MEL_EXN_ID: Stdlib.Exit
                });
      }
    }
    return Stdlib__Obj.Ephemeron.get_data(eph);
  }
  catch (raw_exn){
    const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Stdlib.Exit) {
      return ;
    }
    throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
  }
}

function MakeSeeded$2(H) {
  const create = function (k, d) {
    const c = Stdlib__Obj.Ephemeron.create(k.length);
    Stdlib__Obj.Ephemeron.set_data(c, d);
    for(let i = 0 ,i_finish = k.length; i < i_finish; ++i){
      set_key$1(c, i, Caml_array.get(k, i));
    }
    return c;
  };
  const seeded_hash = function (seed, k) {
    let h = 0;
    for(let i = 0 ,i_finish = k.length; i < i_finish; ++i){
      h = Math.imul(Curry._2(H.seeded_hash, seed, Caml_array.get(k, i)), 65599) + h | 0;
    }
    return h;
  };
  const equal = function (c, k) {
    const len = k.length;
    const len$p = Stdlib__Obj.Ephemeron.length(c);
    if (len !== len$p) {
      return /* EFalse */1;
    }
    let _i = len - 1 | 0;
    while(true) {
      const i = _i;
      if (i < 0) {
        return /* ETrue */0;
      }
      const ki = Stdlib__Obj.Ephemeron.get_key(c, i);
      if (ki === undefined) {
        return /* EDead */2;
      }
      if (!Curry._2(H.equal, Caml_array.get(k, i), Caml_option.valFromOption(ki))) {
        return /* EFalse */1;
      }
      _i = i - 1 | 0;
      continue ;
    };
  };
  const check_key = function (c) {
    let _i = Stdlib__Obj.Ephemeron.length(c) - 1 | 0;
    while(true) {
      const i = _i;
      if (i < 0) {
        return true;
      }
      if (!Stdlib__Obj.Ephemeron.check_key(c, i)) {
        return false;
      }
      _i = i - 1 | 0;
      continue ;
    };
  };
  const power_2_above = function (_x, n) {
    while(true) {
      const x = _x;
      if (x >= n) {
        return x;
      }
      if ((x << 1) > Stdlib__Sys.max_array_length) {
        return x;
      }
      _x = (x << 1);
      continue ;
    };
  };
  const prng = {
    LAZY_DONE: false,
    VAL: (function () {
        return Stdlib__Random.State.make_self_init(undefined);
      })
  };
  const create$1 = function (randomOpt, initial_size) {
    const random = randomOpt !== undefined ? randomOpt : Stdlib__Hashtbl.is_randomized(undefined);
    const s = power_2_above(16, initial_size);
    const seed = random ? Stdlib__Random.State.bits(CamlinternalLazy.force(prng)) : 0;
    return {
            size: 0,
            data: Caml_array.make(s, /* Empty */0),
            seed: seed,
            initial_size: s
          };
  };
  const clear = function (h) {
    h.size = 0;
    const len = h.data.length;
    for(let i = 0; i < len; ++i){
      Caml_array.set(h.data, i, /* Empty */0);
    }
  };
  const reset = function (h) {
    const len = h.data.length;
    if (len === h.initial_size) {
      return clear(h);
    } else {
      h.size = 0;
      h.data = Caml_array.make(h.initial_size, /* Empty */0);
      return ;
    }
  };
  const copy = function (h) {
    return {
            size: h.size,
            data: Stdlib__Array.copy(h.data),
            seed: h.seed,
            initial_size: h.initial_size
          };
  };
  const key_index = function (h, hkey) {
    return hkey & (h.data.length - 1 | 0);
  };
  const clean = function (h) {
    const do_bucket = function (_param) {
      while(true) {
        const param = _param;
        if (!param) {
          return /* Empty */0;
        }
        if (check_key(param._1)) {
          return /* Cons */{
                  _0: param._0,
                  _1: param._1,
                  _2: do_bucket(param._2)
                };
        }
        h.size = h.size - 1 | 0;
        _param = param._2;
        continue ;
      };
    };
    const d = h.data;
    for(let i = 0 ,i_finish = d.length; i < i_finish; ++i){
      Caml_array.set(d, i, do_bucket(Caml_array.get(d, i)));
    }
  };
  const resize = function (h) {
    const odata = h.data;
    const osize = odata.length;
    const nsize = (osize << 1);
    clean(h);
    if (!(nsize < Stdlib__Sys.max_array_length && h.size >= (osize >>> 1))) {
      return ;
    }
    const ndata = Caml_array.make(nsize, /* Empty */0);
    h.data = ndata;
    const insert_bucket = function (param) {
      if (!param) {
        return ;
      }
      const hkey = param._0;
      insert_bucket(param._2);
      const nidx = key_index(h, hkey);
      Caml_array.set(ndata, nidx, /* Cons */{
            _0: hkey,
            _1: param._1,
            _2: Caml_array.get(ndata, nidx)
          });
    };
    for(let i = 0; i < osize; ++i){
      insert_bucket(Caml_array.get(odata, i));
    }
  };
  const add = function (h, key, info) {
    const hkey = seeded_hash(h.seed, key);
    const i = key_index(h, hkey);
    const container = create(key, info);
    const bucket_2 = Caml_array.get(h.data, i);
    const bucket = /* Cons */{
      _0: hkey,
      _1: container,
      _2: bucket_2
    };
    Caml_array.set(h.data, i, bucket);
    h.size = h.size + 1 | 0;
    if (h.size > (h.data.length << 1)) {
      return resize(h);
    }
    
  };
  const remove = function (h, key) {
    const hkey = seeded_hash(h.seed, key);
    const remove_bucket = function (_param) {
      while(true) {
        const param = _param;
        if (!param) {
          return /* Empty */0;
        }
        const hk = param._0;
        if (hkey !== hk) {
          return /* Cons */{
                  _0: hk,
                  _1: param._1,
                  _2: remove_bucket(param._2)
                };
        }
        const next = param._2;
        const c = param._1;
        const match = equal(c, key);
        switch (match) {
          case /* ETrue */0 :
              h.size = h.size - 1 | 0;
              return next;
          case /* EFalse */1 :
              return /* Cons */{
                      _0: hk,
                      _1: c,
                      _2: remove_bucket(next)
                    };
          case /* EDead */2 :
              h.size = h.size - 1 | 0;
              _param = next;
              continue ;
          
        }
      };
    };
    const i = key_index(h, hkey);
    Caml_array.set(h.data, i, remove_bucket(Caml_array.get(h.data, i)));
  };
  const find = function (h, key) {
    const hkey = seeded_hash(h.seed, key);
    let _param = Caml_array.get(h.data, key_index(h, hkey));
    while(true) {
      const param = _param;
      if (param) {
        if (hkey === param._0) {
          const rest = param._2;
          const c = param._1;
          const match = equal(c, key);
          if (match) {
            _param = rest;
            continue ;
          }
          const d = get_data$2(c);
          if (d !== undefined) {
            return Caml_option.valFromOption(d);
          }
          _param = rest;
          continue ;
        }
        _param = param._2;
        continue ;
      }
      throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
                MEL_EXN_ID: Stdlib.Not_found
              });
    };
  };
  const find_opt = function (h, key) {
    const hkey = seeded_hash(h.seed, key);
    let _param = Caml_array.get(h.data, key_index(h, hkey));
    while(true) {
      const param = _param;
      if (!param) {
        return ;
      }
      if (hkey === param._0) {
        const rest = param._2;
        const c = param._1;
        const match = equal(c, key);
        if (match) {
          _param = rest;
          continue ;
        }
        const d = get_data$2(c);
        if (d !== undefined) {
          return d;
        }
        _param = rest;
        continue ;
      }
      _param = param._2;
      continue ;
    };
  };
  const find_all = function (h, key) {
    const hkey = seeded_hash(h.seed, key);
    const find_in_bucket = function (_param) {
      while(true) {
        const param = _param;
        if (!param) {
          return /* [] */0;
        }
        if (hkey === param._0) {
          const rest = param._2;
          const c = param._1;
          const match = equal(c, key);
          if (match) {
            _param = rest;
            continue ;
          }
          const d = get_data$2(c);
          if (d !== undefined) {
            return {
                    hd: Caml_option.valFromOption(d),
                    tl: find_in_bucket(rest)
                  };
          }
          _param = rest;
          continue ;
        }
        _param = param._2;
        continue ;
      };
    };
    return find_in_bucket(Caml_array.get(h.data, key_index(h, hkey)));
  };
  const replace = function (h, key, info) {
    const hkey = seeded_hash(h.seed, key);
    const i = key_index(h, hkey);
    const l = Caml_array.get(h.data, i);
    try {
      let _param = l;
      while(true) {
        const param = _param;
        if (param) {
          if (hkey === param._0) {
            const c = param._1;
            const match = equal(c, key);
            if (!match) {
              Stdlib__Obj.Ephemeron.unset_data(c);
              for(let i$1 = 0 ,i_finish = key.length; i$1 < i_finish; ++i$1){
                set_key$1(c, i$1, Caml_array.get(key, i$1));
              }
              return Stdlib__Obj.Ephemeron.set_data(c, info);
            }
            _param = param._2;
            continue ;
          }
          _param = param._2;
          continue ;
        }
        throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
                  MEL_EXN_ID: Stdlib.Not_found
                });
      };
    }
    catch (raw_exn){
      const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
      if (exn.MEL_EXN_ID === Stdlib.Not_found) {
        const container = create(key, info);
        Caml_array.set(h.data, i, /* Cons */{
              _0: hkey,
              _1: container,
              _2: l
            });
        h.size = h.size + 1 | 0;
        if (h.size > (h.data.length << 1)) {
          return resize(h);
        } else {
          return ;
        }
      }
      throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
    }
  };
  const mem = function (h, key) {
    const hkey = seeded_hash(h.seed, key);
    let _param = Caml_array.get(h.data, key_index(h, hkey));
    while(true) {
      const param = _param;
      if (!param) {
        return false;
      }
      if (param._0 === hkey) {
        const match = equal(param._1, key);
        if (!match) {
          return true;
        }
        _param = param._2;
        continue ;
      }
      _param = param._2;
      continue ;
    };
  };
  const length = function (h) {
    return h.size;
  };
  const bucket_length = function (_accu, _param) {
    while(true) {
      const param = _param;
      const accu = _accu;
      if (!param) {
        return accu;
      }
      _param = param._2;
      _accu = accu + 1 | 0;
      continue ;
    };
  };
  const stats = function (h) {
    const mbl = Stdlib__Array.fold_left((function (m, b) {
            return Stdlib__Int.max(m, bucket_length(0, b));
          }), 0, h.data);
    const histo = Caml_array.make(mbl + 1 | 0, 0);
    Stdlib__Array.iter((function (b) {
            const l = bucket_length(0, b);
            Caml_array.set(histo, l, Caml_array.get(histo, l) + 1 | 0);
          }), h.data);
    return {
            num_bindings: h.size,
            num_buckets: h.data.length,
            max_bucket_length: mbl,
            bucket_histogram: histo
          };
  };
  const bucket_length_alive = function (_accu, _param) {
    while(true) {
      const param = _param;
      const accu = _accu;
      if (!param) {
        return accu;
      }
      if (check_key(param._1)) {
        _param = param._2;
        _accu = accu + 1 | 0;
        continue ;
      }
      _param = param._2;
      continue ;
    };
  };
  const stats_alive = function (h) {
    const size = {
      contents: 0
    };
    const mbl = Stdlib__Array.fold_left((function (m, b) {
            return Stdlib__Int.max(m, bucket_length_alive(0, b));
          }), 0, h.data);
    const histo = Caml_array.make(mbl + 1 | 0, 0);
    Stdlib__Array.iter((function (b) {
            const l = bucket_length_alive(0, b);
            size.contents = size.contents + l | 0;
            Caml_array.set(histo, l, Caml_array.get(histo, l) + 1 | 0);
          }), h.data);
    return {
            num_bindings: size.contents,
            num_buckets: h.data.length,
            max_bucket_length: mbl,
            bucket_histogram: histo
          };
  };
  const add_seq = function (tbl, i) {
    Stdlib__Seq.iter((function (param) {
            add(tbl, param[0], param[1]);
          }), i);
  };
  const replace_seq = function (tbl, i) {
    Stdlib__Seq.iter((function (param) {
            replace(tbl, param[0], param[1]);
          }), i);
  };
  const of_seq = function (i) {
    const tbl = create$1(undefined, 16);
    replace_seq(tbl, i);
    return tbl;
  };
  return {
          create: create$1,
          clear: clear,
          reset: reset,
          copy: copy,
          add: add,
          remove: remove,
          find: find,
          find_opt: find_opt,
          find_all: find_all,
          replace: replace,
          mem: mem,
          length: length,
          stats: stats,
          add_seq: add_seq,
          replace_seq: replace_seq,
          of_seq: of_seq,
          clean: clean,
          stats_alive: stats_alive
        };
}

function Make$2(H) {
  const equal = H.equal;
  const create = function (k, d) {
    const c = Stdlib__Obj.Ephemeron.create(k.length);
    Stdlib__Obj.Ephemeron.set_data(c, d);
    for(let i = 0 ,i_finish = k.length; i < i_finish; ++i){
      set_key$1(c, i, Caml_array.get(k, i));
    }
    return c;
  };
  const seeded_hash = function (seed, k) {
    let h = 0;
    for(let i = 0 ,i_finish = k.length; i < i_finish; ++i){
      h = Math.imul(Curry._1(H.hash, Caml_array.get(k, i)), 65599) + h | 0;
    }
    return h;
  };
  const equal$1 = function (c, k) {
    const len = k.length;
    const len$p = Stdlib__Obj.Ephemeron.length(c);
    if (len !== len$p) {
      return /* EFalse */1;
    }
    let _i = len - 1 | 0;
    while(true) {
      const i = _i;
      if (i < 0) {
        return /* ETrue */0;
      }
      const ki = Stdlib__Obj.Ephemeron.get_key(c, i);
      if (ki === undefined) {
        return /* EDead */2;
      }
      if (!Curry._2(equal, Caml_array.get(k, i), Caml_option.valFromOption(ki))) {
        return /* EFalse */1;
      }
      _i = i - 1 | 0;
      continue ;
    };
  };
  const check_key = function (c) {
    let _i = Stdlib__Obj.Ephemeron.length(c) - 1 | 0;
    while(true) {
      const i = _i;
      if (i < 0) {
        return true;
      }
      if (!Stdlib__Obj.Ephemeron.check_key(c, i)) {
        return false;
      }
      _i = i - 1 | 0;
      continue ;
    };
  };
  const power_2_above = function (_x, n) {
    while(true) {
      const x = _x;
      if (x >= n) {
        return x;
      }
      if ((x << 1) > Stdlib__Sys.max_array_length) {
        return x;
      }
      _x = (x << 1);
      continue ;
    };
  };
  const prng = {
    LAZY_DONE: false,
    VAL: (function () {
        return Stdlib__Random.State.make_self_init(undefined);
      })
  };
  const create$1 = function (randomOpt, initial_size) {
    const random = randomOpt !== undefined ? randomOpt : Stdlib__Hashtbl.is_randomized(undefined);
    const s = power_2_above(16, initial_size);
    const seed = random ? Stdlib__Random.State.bits(CamlinternalLazy.force(prng)) : 0;
    return {
            size: 0,
            data: Caml_array.make(s, /* Empty */0),
            seed: seed,
            initial_size: s
          };
  };
  const clear = function (h) {
    h.size = 0;
    const len = h.data.length;
    for(let i = 0; i < len; ++i){
      Caml_array.set(h.data, i, /* Empty */0);
    }
  };
  const reset = function (h) {
    const len = h.data.length;
    if (len === h.initial_size) {
      return clear(h);
    } else {
      h.size = 0;
      h.data = Caml_array.make(h.initial_size, /* Empty */0);
      return ;
    }
  };
  const copy = function (h) {
    return {
            size: h.size,
            data: Stdlib__Array.copy(h.data),
            seed: h.seed,
            initial_size: h.initial_size
          };
  };
  const key_index = function (h, hkey) {
    return hkey & (h.data.length - 1 | 0);
  };
  const clean = function (h) {
    const do_bucket = function (_param) {
      while(true) {
        const param = _param;
        if (!param) {
          return /* Empty */0;
        }
        if (check_key(param._1)) {
          return /* Cons */{
                  _0: param._0,
                  _1: param._1,
                  _2: do_bucket(param._2)
                };
        }
        h.size = h.size - 1 | 0;
        _param = param._2;
        continue ;
      };
    };
    const d = h.data;
    for(let i = 0 ,i_finish = d.length; i < i_finish; ++i){
      Caml_array.set(d, i, do_bucket(Caml_array.get(d, i)));
    }
  };
  const resize = function (h) {
    const odata = h.data;
    const osize = odata.length;
    const nsize = (osize << 1);
    clean(h);
    if (!(nsize < Stdlib__Sys.max_array_length && h.size >= (osize >>> 1))) {
      return ;
    }
    const ndata = Caml_array.make(nsize, /* Empty */0);
    h.data = ndata;
    const insert_bucket = function (param) {
      if (!param) {
        return ;
      }
      const hkey = param._0;
      insert_bucket(param._2);
      const nidx = key_index(h, hkey);
      Caml_array.set(ndata, nidx, /* Cons */{
            _0: hkey,
            _1: param._1,
            _2: Caml_array.get(ndata, nidx)
          });
    };
    for(let i = 0; i < osize; ++i){
      insert_bucket(Caml_array.get(odata, i));
    }
  };
  const add = function (h, key, info) {
    const hkey = seeded_hash(h.seed, key);
    const i = key_index(h, hkey);
    const container = create(key, info);
    const bucket_2 = Caml_array.get(h.data, i);
    const bucket = /* Cons */{
      _0: hkey,
      _1: container,
      _2: bucket_2
    };
    Caml_array.set(h.data, i, bucket);
    h.size = h.size + 1 | 0;
    if (h.size > (h.data.length << 1)) {
      return resize(h);
    }
    
  };
  const remove = function (h, key) {
    const hkey = seeded_hash(h.seed, key);
    const remove_bucket = function (_param) {
      while(true) {
        const param = _param;
        if (!param) {
          return /* Empty */0;
        }
        const hk = param._0;
        if (hkey !== hk) {
          return /* Cons */{
                  _0: hk,
                  _1: param._1,
                  _2: remove_bucket(param._2)
                };
        }
        const next = param._2;
        const c = param._1;
        const match = equal$1(c, key);
        switch (match) {
          case /* ETrue */0 :
              h.size = h.size - 1 | 0;
              return next;
          case /* EFalse */1 :
              return /* Cons */{
                      _0: hk,
                      _1: c,
                      _2: remove_bucket(next)
                    };
          case /* EDead */2 :
              h.size = h.size - 1 | 0;
              _param = next;
              continue ;
          
        }
      };
    };
    const i = key_index(h, hkey);
    Caml_array.set(h.data, i, remove_bucket(Caml_array.get(h.data, i)));
  };
  const find = function (h, key) {
    const hkey = seeded_hash(h.seed, key);
    let _param = Caml_array.get(h.data, key_index(h, hkey));
    while(true) {
      const param = _param;
      if (param) {
        if (hkey === param._0) {
          const rest = param._2;
          const c = param._1;
          const match = equal$1(c, key);
          if (match) {
            _param = rest;
            continue ;
          }
          const d = get_data$2(c);
          if (d !== undefined) {
            return Caml_option.valFromOption(d);
          }
          _param = rest;
          continue ;
        }
        _param = param._2;
        continue ;
      }
      throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
                MEL_EXN_ID: Stdlib.Not_found
              });
    };
  };
  const find_opt = function (h, key) {
    const hkey = seeded_hash(h.seed, key);
    let _param = Caml_array.get(h.data, key_index(h, hkey));
    while(true) {
      const param = _param;
      if (!param) {
        return ;
      }
      if (hkey === param._0) {
        const rest = param._2;
        const c = param._1;
        const match = equal$1(c, key);
        if (match) {
          _param = rest;
          continue ;
        }
        const d = get_data$2(c);
        if (d !== undefined) {
          return d;
        }
        _param = rest;
        continue ;
      }
      _param = param._2;
      continue ;
    };
  };
  const find_all = function (h, key) {
    const hkey = seeded_hash(h.seed, key);
    const find_in_bucket = function (_param) {
      while(true) {
        const param = _param;
        if (!param) {
          return /* [] */0;
        }
        if (hkey === param._0) {
          const rest = param._2;
          const c = param._1;
          const match = equal$1(c, key);
          if (match) {
            _param = rest;
            continue ;
          }
          const d = get_data$2(c);
          if (d !== undefined) {
            return {
                    hd: Caml_option.valFromOption(d),
                    tl: find_in_bucket(rest)
                  };
          }
          _param = rest;
          continue ;
        }
        _param = param._2;
        continue ;
      };
    };
    return find_in_bucket(Caml_array.get(h.data, key_index(h, hkey)));
  };
  const replace = function (h, key, info) {
    const hkey = seeded_hash(h.seed, key);
    const i = key_index(h, hkey);
    const l = Caml_array.get(h.data, i);
    try {
      let _param = l;
      while(true) {
        const param = _param;
        if (param) {
          if (hkey === param._0) {
            const c = param._1;
            const match = equal$1(c, key);
            if (!match) {
              Stdlib__Obj.Ephemeron.unset_data(c);
              for(let i$1 = 0 ,i_finish = key.length; i$1 < i_finish; ++i$1){
                set_key$1(c, i$1, Caml_array.get(key, i$1));
              }
              return Stdlib__Obj.Ephemeron.set_data(c, info);
            }
            _param = param._2;
            continue ;
          }
          _param = param._2;
          continue ;
        }
        throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
                  MEL_EXN_ID: Stdlib.Not_found
                });
      };
    }
    catch (raw_exn){
      const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
      if (exn.MEL_EXN_ID === Stdlib.Not_found) {
        const container = create(key, info);
        Caml_array.set(h.data, i, /* Cons */{
              _0: hkey,
              _1: container,
              _2: l
            });
        h.size = h.size + 1 | 0;
        if (h.size > (h.data.length << 1)) {
          return resize(h);
        } else {
          return ;
        }
      }
      throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
    }
  };
  const mem = function (h, key) {
    const hkey = seeded_hash(h.seed, key);
    let _param = Caml_array.get(h.data, key_index(h, hkey));
    while(true) {
      const param = _param;
      if (!param) {
        return false;
      }
      if (param._0 === hkey) {
        const match = equal$1(param._1, key);
        if (!match) {
          return true;
        }
        _param = param._2;
        continue ;
      }
      _param = param._2;
      continue ;
    };
  };
  const length = function (h) {
    return h.size;
  };
  const bucket_length = function (_accu, _param) {
    while(true) {
      const param = _param;
      const accu = _accu;
      if (!param) {
        return accu;
      }
      _param = param._2;
      _accu = accu + 1 | 0;
      continue ;
    };
  };
  const stats = function (h) {
    const mbl = Stdlib__Array.fold_left((function (m, b) {
            return Stdlib__Int.max(m, bucket_length(0, b));
          }), 0, h.data);
    const histo = Caml_array.make(mbl + 1 | 0, 0);
    Stdlib__Array.iter((function (b) {
            const l = bucket_length(0, b);
            Caml_array.set(histo, l, Caml_array.get(histo, l) + 1 | 0);
          }), h.data);
    return {
            num_bindings: h.size,
            num_buckets: h.data.length,
            max_bucket_length: mbl,
            bucket_histogram: histo
          };
  };
  const bucket_length_alive = function (_accu, _param) {
    while(true) {
      const param = _param;
      const accu = _accu;
      if (!param) {
        return accu;
      }
      if (check_key(param._1)) {
        _param = param._2;
        _accu = accu + 1 | 0;
        continue ;
      }
      _param = param._2;
      continue ;
    };
  };
  const stats_alive = function (h) {
    const size = {
      contents: 0
    };
    const mbl = Stdlib__Array.fold_left((function (m, b) {
            return Stdlib__Int.max(m, bucket_length_alive(0, b));
          }), 0, h.data);
    const histo = Caml_array.make(mbl + 1 | 0, 0);
    Stdlib__Array.iter((function (b) {
            const l = bucket_length_alive(0, b);
            size.contents = size.contents + l | 0;
            Caml_array.set(histo, l, Caml_array.get(histo, l) + 1 | 0);
          }), h.data);
    return {
            num_bindings: size.contents,
            num_buckets: h.data.length,
            max_bucket_length: mbl,
            bucket_histogram: histo
          };
  };
  const add_seq = function (tbl, i) {
    Stdlib__Seq.iter((function (param) {
            add(tbl, param[0], param[1]);
          }), i);
  };
  const replace_seq = function (tbl, i) {
    Stdlib__Seq.iter((function (param) {
            replace(tbl, param[0], param[1]);
          }), i);
  };
  const create$2 = function (sz) {
    return create$1(false, sz);
  };
  const of_seq = function (i) {
    const tbl = create$1(false, 16);
    replace_seq(tbl, i);
    return tbl;
  };
  return {
          create: create$2,
          clear: clear,
          reset: reset,
          copy: copy,
          add: add,
          remove: remove,
          find: find,
          find_opt: find_opt,
          find_all: find_all,
          replace: replace,
          mem: mem,
          length: length,
          stats: stats,
          add_seq: add_seq,
          replace_seq: replace_seq,
          of_seq: of_seq,
          clean: clean,
          stats_alive: stats_alive
        };
}

function make$5(param) {
  return {
          contents: /* [] */0
        };
}

function add$2(b, k, d) {
  b.contents = {
    hd: make$4(k, d),
    tl: b.contents
  };
}

function test_keys$1(k, e) {
  try {
    if (Stdlib__Obj.Ephemeron.length(e) !== k.length) {
      throw new Caml_js_exceptions.MelangeError(Stdlib.Exit, {
                MEL_EXN_ID: Stdlib.Exit
              });
    }
    for(let i = 0 ,i_finish = k.length; i < i_finish; ++i){
      const x = Stdlib__Obj.Ephemeron.get_key(e, i);
      if (x !== undefined) {
        if (Caml_option.valFromOption(x) !== Caml_array.get(k, i)) {
          throw new Caml_js_exceptions.MelangeError(Stdlib.Exit, {
                    MEL_EXN_ID: Stdlib.Exit
                  });
        }
        
      } else {
        throw new Caml_js_exceptions.MelangeError(Stdlib.Exit, {
                  MEL_EXN_ID: Stdlib.Exit
                });
      }
    }
    return true;
  }
  catch (raw_exn){
    const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Stdlib.Exit) {
      return false;
    }
    throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
  }
}

function remove$2(b, k) {
  let _l = b.contents;
  let _acc = /* [] */0;
  while(true) {
    const acc = _acc;
    const l = _l;
    if (!l) {
      return ;
    }
    const h = l.hd;
    if (test_keys$1(k, h)) {
      b.contents = Stdlib__List.rev_append(acc, l.tl);
      return ;
    }
    _acc = {
      hd: h,
      tl: acc
    };
    _l = l.tl;
    continue ;
  };
}

function find$2(b, k) {
  const e = Stdlib__List.find_opt((function (param) {
          return test_keys$1(k, param);
        }), b.contents);
  if (e !== undefined) {
    return Stdlib__Obj.Ephemeron.get_data(Caml_option.valFromOption(e));
  }
  
}

function length$2(b) {
  return Stdlib__List.length(b.contents);
}

function clear$2(b) {
  b.contents = /* [] */0;
}

const K1_Bucket = {
  make: make$1,
  add: add,
  remove: remove,
  find: find,
  length: length,
  clear: clear
};

const K1 = {
  make: make,
  query: query,
  Make: Make,
  MakeSeeded: MakeSeeded,
  Bucket: K1_Bucket
};

const K2_Bucket = {
  make: make$3,
  add: add$1,
  remove: remove$1,
  find: find$1,
  length: length$1,
  clear: clear$1
};

const K2 = {
  make: make$2,
  query: query$1,
  Make: Make$1,
  MakeSeeded: MakeSeeded$1,
  Bucket: K2_Bucket
};

const Kn_Bucket = {
  make: make$5,
  add: add$2,
  remove: remove$2,
  find: find$2,
  length: length$2,
  clear: clear$2
};

const Kn = {
  make: make$4,
  query: query$2,
  Make: Make$2,
  MakeSeeded: MakeSeeded$2,
  Bucket: Kn_Bucket
};

export {
  K1 ,
  K2 ,
  Kn ,
}
/* Stdlib__Hashtbl Not a pure module */
