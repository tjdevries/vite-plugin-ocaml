// Generated by Melange

import * as Caml from "melange.js/caml.js";
import * as Caml_array from "melange.js/caml_array.js";
import * as Caml_exceptions from "melange.js/caml_exceptions.js";
import * as Caml_external_polyfill from "melange.js/caml_external_polyfill.js";
import * as Caml_hash from "melange.js/caml_hash.js";
import * as Caml_int64 from "melange.js/caml_int64.js";
import * as Caml_js_exceptions from "melange.js/caml_js_exceptions.js";
import * as Curry from "melange.js/curry.js";
import * as Stdlib from "./stdlib.js";
import * as Stdlib__List from "./list.js";
import * as Stdlib__Seq from "./seq.js";

const nan = Number.NaN;

const signaling_nan = Caml_int64.float_of_bits([
      2146435072,
      1
    ]);

function is_finite(x) {
  return x - x === 0;
}

function is_infinite(x) {
  return 1 / x === 0;
}

function is_nan(x) {
  return x !== x;
}

function is_integer(x) {
  if (x === Caml_external_polyfill.resolve("caml_trunc_float")(x)) {
    return is_finite(x);
  } else {
    return false;
  }
}

function succ(x) {
  return Caml_external_polyfill.resolve("caml_nextafter_float")(x, Stdlib.infinity);
}

function pred(x) {
  return Caml_external_polyfill.resolve("caml_nextafter_float")(x, Stdlib.neg_infinity);
}

function equal(x, y) {
  return Caml.caml_float_compare(x, y) === 0;
}

function min(x, y) {
  if (y > x || y >= 0 && x < 0) {
    if (y !== y) {
      return y;
    } else {
      return x;
    }
  } else if (x !== x) {
    return x;
  } else {
    return y;
  }
}

function max(x, y) {
  if (y > x || y >= 0 && x < 0) {
    if (x !== x) {
      return x;
    } else {
      return y;
    }
  } else if (y !== y) {
    return y;
  } else {
    return x;
  }
}

function min_max(x, y) {
  if (x !== x || y !== y) {
    return [
            nan,
            nan
          ];
  } else if (y > x || y >= 0 && x < 0) {
    return [
            x,
            y
          ];
  } else {
    return [
            y,
            x
          ];
  }
}

function min_num(x, y) {
  if (y > x || y >= 0 && x < 0) {
    if (x !== x) {
      return y;
    } else {
      return x;
    }
  } else if (y !== y) {
    return x;
  } else {
    return y;
  }
}

function max_num(x, y) {
  if (y > x || y >= 0 && x < 0) {
    if (y !== y) {
      return x;
    } else {
      return y;
    }
  } else if (x !== x) {
    return y;
  } else {
    return x;
  }
}

function min_max_num(x, y) {
  if (x !== x) {
    return [
            y,
            y
          ];
  } else if (y !== y) {
    return [
            x,
            x
          ];
  } else if (y > x || y >= 0 && x < 0) {
    return [
            x,
            y
          ];
  } else {
    return [
            y,
            x
          ];
  }
}

function seeded_hash(seed, x) {
  return Caml_hash.caml_hash(10, 100, seed, x);
}

function hash(x) {
  return Caml_hash.caml_hash(10, 100, 0, x);
}

function unsafe_fill(a, ofs, len, v) {
  for(let i = ofs ,i_finish = ofs + len | 0; i < i_finish; ++i){
    a[i] = v;
  }
}

function check(a, ofs, len, msg) {
  if (!(ofs < 0 || len < 0 || (ofs + len | 0) < 0 || (ofs + len | 0) > a.length)) {
    return ;
  }
  throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
            MEL_EXN_ID: "Invalid_argument",
            _1: msg
          });
}

function make(n, v) {
  const result = Caml_array.make_float(n);
  unsafe_fill(result, 0, n, v);
  return result;
}

function init(l, f) {
  if (l < 0) {
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
              MEL_EXN_ID: "Invalid_argument",
              _1: "Float.Array.init"
            });
  }
  const res = Caml_array.make_float(l);
  for(let i = 0; i < l; ++i){
    res[i] = Curry._1(f, i);
  }
  return res;
}

function make_matrix(sx, sy, v) {
  if (sy < 0) {
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
              MEL_EXN_ID: "Invalid_argument",
              _1: "Float.Array.make_matrix"
            });
  }
  const res = Caml_array.make(sx, Caml_array.make_float(0));
  if (sy > 0) {
    for(let x = 0; x < sx; ++x){
      res[x] = make(sy, v);
    }
  }
  return res;
}

function init_matrix(sx, sy, f) {
  if (sy < 0) {
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
              MEL_EXN_ID: "Invalid_argument",
              _1: "Float.Array.init_matrix"
            });
  }
  const res = Caml_array.make(sx, Caml_array.make_float(0));
  if (sy > 0) {
    for(let x = 0; x < sx; ++x){
      const row = Caml_array.make_float(sy);
      for(let y = 0; y < sy; ++y){
        row[y] = Curry._2(f, x, y);
      }
      res[x] = row;
    }
  }
  return res;
}

function append(a1, a2) {
  const l1 = a1.length;
  const l2 = a2.length;
  const result = Caml_array.make_float(l1 + l2 | 0);
  Caml_external_polyfill.resolve("caml_floatarray_blit")(a1, 0, result, 0, l1);
  Caml_external_polyfill.resolve("caml_floatarray_blit")(a2, 0, result, l1, l2);
  return result;
}

function ensure_ge(x, y) {
  if (x >= y) {
    return x;
  }
  throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
            MEL_EXN_ID: "Invalid_argument",
            _1: "Float.Array.concat"
          });
}

function sum_lengths(_acc, _param) {
  while(true) {
    const param = _param;
    const acc = _acc;
    if (!param) {
      return acc;
    }
    _param = param.tl;
    _acc = ensure_ge(param.hd.length + acc | 0, acc);
    continue ;
  };
}

function concat(l) {
  const len = sum_lengths(0, l);
  const result = Caml_array.make_float(len);
  const loop = function (_l, _i) {
    while(true) {
      const i = _i;
      const l = _l;
      if (l) {
        const hd = l.hd;
        const hlen = hd.length;
        Caml_external_polyfill.resolve("caml_floatarray_blit")(hd, 0, result, i, hlen);
        _i = i + hlen | 0;
        _l = l.tl;
        continue ;
      }
      if (i === len) {
        return ;
      }
      throw new Caml_js_exceptions.MelangeError("Assert_failure", {
                MEL_EXN_ID: "Assert_failure",
                _1: [
                  "float.cppo.ml",
                  304,
                  14
                ]
              });
    };
  };
  loop(l, 0);
  return result;
}

function sub(a, ofs, len) {
  check(a, ofs, len, "Float.Array.sub");
  const result = Caml_array.make_float(len);
  Caml_external_polyfill.resolve("caml_floatarray_blit")(a, ofs, result, 0, len);
  return result;
}

function copy(a) {
  const l = a.length;
  const result = Caml_array.make_float(l);
  Caml_external_polyfill.resolve("caml_floatarray_blit")(a, 0, result, 0, l);
  return result;
}

function fill(a, ofs, len, v) {
  check(a, ofs, len, "Float.Array.fill");
  unsafe_fill(a, ofs, len, v);
}

function blit(src, sofs, dst, dofs, len) {
  check(src, sofs, len, "Float.array.blit");
  check(dst, dofs, len, "Float.array.blit");
  Caml_external_polyfill.resolve("caml_floatarray_blit")(src, sofs, dst, dofs, len);
}

function to_list(a) {
  return Stdlib__List.init(a.length, (function (param) {
                return a[param];
              }));
}

function of_list(l) {
  const result = Caml_array.make_float(Stdlib__List.length(l));
  let _i = 0;
  let _l = l;
  while(true) {
    const l$1 = _l;
    const i = _i;
    if (!l$1) {
      return result;
    }
    result[i] = l$1.hd;
    _l = l$1.tl;
    _i = i + 1 | 0;
    continue ;
  };
}

function iter(f, a) {
  for(let i = 0 ,i_finish = a.length; i < i_finish; ++i){
    Curry._1(f, a[i]);
  }
}

function iter2(f, a, b) {
  if (a.length !== b.length) {
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
              MEL_EXN_ID: "Invalid_argument",
              _1: "Float.Array.iter2: arrays must have the same length"
            });
  }
  for(let i = 0 ,i_finish = a.length; i < i_finish; ++i){
    Curry._2(f, a[i], b[i]);
  }
}

function map(f, a) {
  const l = a.length;
  const r = Caml_array.make_float(l);
  for(let i = 0; i < l; ++i){
    r[i] = Curry._1(f, a[i]);
  }
  return r;
}

function map_inplace(f, a) {
  for(let i = 0 ,i_finish = a.length; i < i_finish; ++i){
    a[i] = Curry._1(f, a[i]);
  }
}

function map2(f, a, b) {
  const la = a.length;
  const lb = b.length;
  if (la !== lb) {
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
              MEL_EXN_ID: "Invalid_argument",
              _1: "Float.Array.map2: arrays must have the same length"
            });
  }
  const r = Caml_array.make_float(la);
  for(let i = 0; i < la; ++i){
    r[i] = Curry._2(f, a[i], b[i]);
  }
  return r;
}

function iteri(f, a) {
  for(let i = 0 ,i_finish = a.length; i < i_finish; ++i){
    Curry._2(f, i, a[i]);
  }
}

function mapi(f, a) {
  const l = a.length;
  const r = Caml_array.make_float(l);
  for(let i = 0; i < l; ++i){
    r[i] = Curry._2(f, i, a[i]);
  }
  return r;
}

function mapi_inplace(f, a) {
  for(let i = 0 ,i_finish = a.length; i < i_finish; ++i){
    a[i] = Curry._2(f, i, a[i]);
  }
}

function fold_left(f, x, a) {
  let r = x;
  for(let i = 0 ,i_finish = a.length; i < i_finish; ++i){
    r = Curry._2(f, r, a[i]);
  }
  return r;
}

function fold_right(f, a, x) {
  let r = x;
  for(let i = a.length - 1 | 0; i >= 0; --i){
    r = Curry._2(f, a[i], r);
  }
  return r;
}

function exists(p, a) {
  const n = a.length;
  let _i = 0;
  while(true) {
    const i = _i;
    if (i === n) {
      return false;
    }
    if (Curry._1(p, a[i])) {
      return true;
    }
    _i = i + 1 | 0;
    continue ;
  };
}

function for_all(p, a) {
  const n = a.length;
  let _i = 0;
  while(true) {
    const i = _i;
    if (i === n) {
      return true;
    }
    if (!Curry._1(p, a[i])) {
      return false;
    }
    _i = i + 1 | 0;
    continue ;
  };
}

function mem(x, a) {
  const n = a.length;
  let _i = 0;
  while(true) {
    const i = _i;
    if (i === n) {
      return false;
    }
    if (Caml.caml_float_compare(a[i], x) === 0) {
      return true;
    }
    _i = i + 1 | 0;
    continue ;
  };
}

function mem_ieee(x, a) {
  const n = a.length;
  let _i = 0;
  while(true) {
    const i = _i;
    if (i === n) {
      return false;
    }
    if (x === a[i]) {
      return true;
    }
    _i = i + 1 | 0;
    continue ;
  };
}

function find_opt(p, a) {
  const n = a.length;
  let _i = 0;
  while(true) {
    const i = _i;
    if (i === n) {
      return ;
    }
    const x = a[i];
    if (Curry._1(p, x)) {
      return x;
    }
    _i = i + 1 | 0;
    continue ;
  };
}

function find_index(p, a) {
  const n = a.length;
  let _i = 0;
  while(true) {
    const i = _i;
    if (i === n) {
      return ;
    }
    if (Curry._1(p, a[i])) {
      return i;
    }
    _i = i + 1 | 0;
    continue ;
  };
}

function find_map(f, a) {
  const n = a.length;
  let _i = 0;
  while(true) {
    const i = _i;
    if (i === n) {
      return ;
    }
    const r = Curry._1(f, a[i]);
    if (r !== undefined) {
      return r;
    }
    _i = i + 1 | 0;
    continue ;
  };
}

function find_mapi(f, a) {
  const n = a.length;
  let _i = 0;
  while(true) {
    const i = _i;
    if (i === n) {
      return ;
    }
    const r = Curry._2(f, i, a[i]);
    if (r !== undefined) {
      return r;
    }
    _i = i + 1 | 0;
    continue ;
  };
}

const Bottom = /* @__PURE__ */Caml_exceptions.create("Stdlib.Float.Array.Bottom");

function sort(cmp, a) {
  const maxson = function (l, i) {
    const i31 = ((i + i | 0) + i | 0) + 1 | 0;
    let x = i31;
    if ((i31 + 2 | 0) < l) {
      if (Curry._2(cmp, Caml_array.get(a, i31), Caml_array.get(a, i31 + 1 | 0)) < 0) {
        x = i31 + 1 | 0;
      }
      if (Curry._2(cmp, Caml_array.get(a, x), Caml_array.get(a, i31 + 2 | 0)) < 0) {
        x = i31 + 2 | 0;
      }
      return x;
    }
    if ((i31 + 1 | 0) < l && Curry._2(cmp, Caml_array.get(a, i31), Caml_array.get(a, i31 + 1 | 0)) < 0) {
      return i31 + 1 | 0;
    }
    if (i31 < l) {
      return i31;
    }
    throw new Caml_js_exceptions.MelangeError(Bottom, {
              MEL_EXN_ID: Bottom,
              _1: i
            });
  };
  const trickle = function (l, i, e) {
    try {
      let _i = i;
      while(true) {
        const i$1 = _i;
        const j = maxson(l, i$1);
        if (Curry._2(cmp, Caml_array.get(a, j), e) <= 0) {
          return Caml_array.set(a, i$1, e);
        }
        Caml_array.set(a, i$1, Caml_array.get(a, j));
        _i = j;
        continue ;
      };
    }
    catch (raw_i){
      const i$2 = Caml_js_exceptions.internalToOCamlException(raw_i);
      if (i$2.MEL_EXN_ID === Bottom) {
        return Caml_array.set(a, i$2._1, e);
      }
      throw new Caml_js_exceptions.MelangeError(i$2.MEL_EXN_ID, i$2);
    }
  };
  const bubble = function (l, i) {
    try {
      let _i = i;
      while(true) {
        const i$1 = _i;
        const j = maxson(l, i$1);
        Caml_array.set(a, i$1, Caml_array.get(a, j));
        _i = j;
        continue ;
      };
    }
    catch (raw_i){
      const i$2 = Caml_js_exceptions.internalToOCamlException(raw_i);
      if (i$2.MEL_EXN_ID === Bottom) {
        return i$2._1;
      }
      throw new Caml_js_exceptions.MelangeError(i$2.MEL_EXN_ID, i$2);
    }
  };
  const trickleup = function (_i, e) {
    while(true) {
      const i = _i;
      const father = (i - 1 | 0) / 3 | 0;
      if (i === father) {
        throw new Caml_js_exceptions.MelangeError("Assert_failure", {
                  MEL_EXN_ID: "Assert_failure",
                  _1: [
                    "float.cppo.ml",
                    534,
                    6
                  ]
                });
      }
      if (Curry._2(cmp, Caml_array.get(a, father), e) >= 0) {
        return Caml_array.set(a, i, e);
      }
      Caml_array.set(a, i, Caml_array.get(a, father));
      if (father <= 0) {
        return Caml_array.set(a, 0, e);
      }
      _i = father;
      continue ;
    };
  };
  const l = a.length;
  for(let i = ((l + 1 | 0) / 3 | 0) - 1 | 0; i >= 0; --i){
    trickle(l, i, Caml_array.get(a, i));
  }
  for(let i$1 = l - 1 | 0; i$1 >= 2; --i$1){
    const e = Caml_array.get(a, i$1);
    Caml_array.set(a, i$1, Caml_array.get(a, 0));
    trickleup(bubble(i$1, 0), e);
  }
  if (l <= 1) {
    return ;
  }
  const e$1 = Caml_array.get(a, 1);
  Caml_array.set(a, 1, Caml_array.get(a, 0));
  Caml_array.set(a, 0, e$1);
}

function stable_sort(cmp, a) {
  const merge = function (src1ofs, src1len, src2, src2ofs, src2len, dst, dstofs) {
    const src1r = src1ofs + src1len | 0;
    const src2r = src2ofs + src2len | 0;
    let _i1 = src1ofs;
    let _s1 = Caml_array.get(a, src1ofs);
    let _i2 = src2ofs;
    let _s2 = Caml_array.get(src2, src2ofs);
    let _d = dstofs;
    while(true) {
      const d = _d;
      const s2 = _s2;
      const i2 = _i2;
      const s1 = _s1;
      const i1 = _i1;
      if (Curry._2(cmp, s1, s2) <= 0) {
        Caml_array.set(dst, d, s1);
        const i1$1 = i1 + 1 | 0;
        if (i1$1 >= src1r) {
          return blit(src2, i2, dst, d + 1 | 0, src2r - i2 | 0);
        }
        _d = d + 1 | 0;
        _s1 = Caml_array.get(a, i1$1);
        _i1 = i1$1;
        continue ;
      }
      Caml_array.set(dst, d, s2);
      const i2$1 = i2 + 1 | 0;
      if (i2$1 >= src2r) {
        return blit(a, i1, dst, d + 1 | 0, src1r - i1 | 0);
      }
      _d = d + 1 | 0;
      _s2 = Caml_array.get(src2, i2$1);
      _i2 = i2$1;
      continue ;
    };
  };
  const isortto = function (srcofs, dst, dstofs, len) {
    for(let i = 0; i < len; ++i){
      const e = Caml_array.get(a, srcofs + i | 0);
      let j = (dstofs + i | 0) - 1 | 0;
      while(j >= dstofs && Curry._2(cmp, Caml_array.get(dst, j), e) > 0) {
        Caml_array.set(dst, j + 1 | 0, Caml_array.get(dst, j));
        j = j - 1 | 0;
      };
      Caml_array.set(dst, j + 1 | 0, e);
    }
  };
  const sortto = function (srcofs, dst, dstofs, len) {
    if (len <= 5) {
      return isortto(srcofs, dst, dstofs, len);
    }
    const l1 = len / 2 | 0;
    const l2 = len - l1 | 0;
    sortto(srcofs + l1 | 0, dst, dstofs + l1 | 0, l2);
    sortto(srcofs, a, srcofs + l2 | 0, l1);
    merge(srcofs + l2 | 0, l1, dst, dstofs + l1 | 0, l2, dst, dstofs);
  };
  const l = a.length;
  if (l <= 5) {
    return isortto(0, a, 0, l);
  }
  const l1 = l / 2 | 0;
  const l2 = l - l1 | 0;
  const t = Caml_array.make_float(l2);
  sortto(l1, t, 0, l2);
  sortto(0, a, l2, l1);
  merge(l2, l1, t, 0, l2, a, 0);
}

function shuffle(rand, a) {
  for(let i = a.length - 1 | 0; i >= 1; --i){
    const j = Curry._1(rand, i + 1 | 0);
    const v = a[i];
    a[i] = Caml_array.get(a, j);
    a[j] = v;
  }
}

function to_seq(a) {
  const aux = function (i, param) {
    if (i >= a.length) {
      return /* Nil */0;
    }
    const x = a[i];
    const partial_arg = i + 1 | 0;
    return /* Cons */{
            _0: x,
            _1: (function (param) {
                return aux(partial_arg, param);
              })
          };
  };
  return function (param) {
    return aux(0, param);
  };
}

function to_seqi(a) {
  const aux = function (i, param) {
    if (i >= a.length) {
      return /* Nil */0;
    }
    const x = a[i];
    const partial_arg = i + 1 | 0;
    return /* Cons */{
            _0: [
              i,
              x
            ],
            _1: (function (param) {
                return aux(partial_arg, param);
              })
          };
  };
  return function (param) {
    return aux(0, param);
  };
}

function of_seq(i) {
  let l = Stdlib__Seq.fold_left((function (acc, x) {
          return {
                  hd: x,
                  tl: acc
                };
        }), /* [] */0, i);
  const len = Stdlib__List.length(l);
  const a = Caml_array.make_float(len);
  let _i = len - 1 | 0;
  let _param = l;
  while(true) {
    const param = _param;
    const i$1 = _i;
    if (!param) {
      return a;
    }
    a[i$1] = param.hd;
    _param = param.tl;
    _i = i$1 - 1 | 0;
    continue ;
  };
}

function map_to_array(f, a) {
  const l = a.length;
  if (l === 0) {
    return [];
  }
  const r = Caml_array.make(l, Curry._1(f, a[0]));
  for(let i = 1; i < l; ++i){
    r[i] = Curry._1(f, a[i]);
  }
  return r;
}

function map_from_array(f, a) {
  const l = a.length;
  const r = Caml_array.make_float(l);
  for(let i = 0; i < l; ++i){
    r[i] = Curry._1(f, a[i]);
  }
  return r;
}

const zero = 0;

const one = 1;

const minus_one = -1;

const infinity = Stdlib.infinity;

const neg_infinity = Stdlib.neg_infinity;

const quiet_nan = nan;

const pi = 3.14159265358979312;

const max_float = Stdlib.max_float;

const min_float = Stdlib.min_float;

const epsilon = Stdlib.epsilon_float;

const of_string_opt = Stdlib.float_of_string_opt;

const to_string = Stdlib.string_of_float;

const compare = Caml.caml_float_compare;

function Array_length(prim) {
  return prim.length;
}

const Array_get = Caml_array.get;

const Array_set = Caml_array.set;

const Array_create = Caml_array.make_float;

const $$Array = {
  length: Array_length,
  get: Array_get,
  set: Array_set,
  make: make,
  create: Array_create,
  init: init,
  make_matrix: make_matrix,
  init_matrix: init_matrix,
  append: append,
  concat: concat,
  sub: sub,
  copy: copy,
  fill: fill,
  blit: blit,
  to_list: to_list,
  of_list: of_list,
  iter: iter,
  iteri: iteri,
  map: map,
  map_inplace: map_inplace,
  mapi: mapi,
  mapi_inplace: mapi_inplace,
  fold_left: fold_left,
  fold_right: fold_right,
  iter2: iter2,
  map2: map2,
  for_all: for_all,
  exists: exists,
  mem: mem,
  mem_ieee: mem_ieee,
  find_opt: find_opt,
  find_index: find_index,
  find_map: find_map,
  find_mapi: find_mapi,
  sort: sort,
  stable_sort: stable_sort,
  fast_sort: stable_sort,
  shuffle: shuffle,
  to_seq: to_seq,
  to_seqi: to_seqi,
  of_seq: of_seq,
  map_to_array: map_to_array,
  map_from_array: map_from_array
};

export {
  zero ,
  one ,
  minus_one ,
  succ ,
  pred ,
  infinity ,
  neg_infinity ,
  nan ,
  signaling_nan ,
  quiet_nan ,
  pi ,
  max_float ,
  min_float ,
  epsilon ,
  is_finite ,
  is_infinite ,
  is_nan ,
  is_integer ,
  of_string_opt ,
  to_string ,
  compare ,
  equal ,
  min ,
  max ,
  min_max ,
  min_num ,
  max_num ,
  min_max_num ,
  seeded_hash ,
  hash ,
  $$Array ,
}
/* nan Not a pure module */
