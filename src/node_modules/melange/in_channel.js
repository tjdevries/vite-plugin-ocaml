// Generated by Melange

import * as Caml_bytes from "melange.js/caml_bytes.js";
import * as Caml_external_polyfill from "melange.js/caml_external_polyfill.js";
import * as Caml_js_exceptions from "melange.js/caml_js_exceptions.js";
import * as Caml_option from "melange.js/caml_option.js";
import * as Curry from "melange.js/curry.js";
import * as Stdlib from "./stdlib.js";
import * as Stdlib__Bytes from "./bytes.js";
import * as Stdlib__Fun from "./fun.js";
import * as Stdlib__Sys from "./sys.js";

function with_open(openfun, s, f) {
  const ic = Curry._1(openfun, s);
  return Stdlib__Fun.protect((function (param) {
                Stdlib.close_in_noerr(ic);
              }), (function (param) {
                return Curry._1(f, ic);
              }));
}

function with_open_bin(s, f) {
  return with_open(Stdlib.open_in_bin, s, f);
}

function with_open_text(s, f) {
  return with_open(Stdlib.open_in, s, f);
}

function with_open_gen(flags, perm, s, f) {
  return with_open((function (param) {
                return Stdlib.open_in_gen(flags, perm, param);
              }), s, f);
}

const seek = Stdlib.LargeFile.seek_in;

const pos = Stdlib.LargeFile.pos_in;

const length = Stdlib.LargeFile.in_channel_length;

function input_char(ic) {
  let c;
  try {
    c = Caml_external_polyfill.resolve("caml_ml_input_char")(ic);
  }
  catch (raw_exn){
    const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Stdlib.End_of_file) {
      return ;
    }
    throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
  }
  return c;
}

function input_byte(ic) {
  let n;
  try {
    n = Caml_external_polyfill.resolve("caml_ml_input_char")(ic);
  }
  catch (raw_exn){
    const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Stdlib.End_of_file) {
      return ;
    }
    throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
  }
  return n;
}

function input_line(ic) {
  let s;
  try {
    s = Stdlib.input_line(ic);
  }
  catch (raw_exn){
    const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Stdlib.End_of_file) {
      return ;
    }
    throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
  }
  return s;
}

function really_input(ic, buf, pos, len) {
  try {
    Stdlib.really_input(ic, buf, pos, len);
    return Caml_option.some(undefined);
  }
  catch (raw_exn){
    const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Stdlib.End_of_file) {
      return ;
    }
    throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
  }
}

function really_input_string(ic, len) {
  let s;
  try {
    s = Stdlib.really_input_string(ic, len);
  }
  catch (raw_exn){
    const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Stdlib.End_of_file) {
      return ;
    }
    throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
  }
  return s;
}

function read_upto(ic, buf, ofs, len) {
  const loop = function (_ofs, _len) {
    while(true) {
      const len = _len;
      const ofs = _ofs;
      if (len === 0) {
        return ofs;
      }
      const r = Stdlib.input(ic, buf, ofs, len);
      if (r === 0) {
        return ofs;
      }
      _len = len - r | 0;
      _ofs = ofs + r | 0;
      continue ;
    };
  };
  return loop(ofs, len) - ofs | 0;
}

function ensure(buf, ofs, n) {
  const len = buf.length;
  if (len >= (ofs + n | 0)) {
    return buf;
  }
  let new_len = len;
  while(new_len < (ofs + n | 0)) {
    new_len = (new_len << 1) + 1 | 0;
  };
  const new_len$1 = new_len;
  let new_len$2;
  if (new_len$1 <= Stdlib__Sys.max_string_length) {
    new_len$2 = new_len$1;
  } else if (ofs < Stdlib__Sys.max_string_length) {
    new_len$2 = Stdlib__Sys.max_string_length;
  } else {
    throw new Caml_js_exceptions.MelangeError("Failure", {
              MEL_EXN_ID: "Failure",
              _1: "In_channel.input_all: channel content is larger than maximum string length"
            });
  }
  const new_buf = Caml_bytes.caml_create_bytes(new_len$2);
  Stdlib__Bytes.blit(buf, 0, new_buf, 0, ofs);
  return new_buf;
}

function input_all(ic) {
  let initial_size;
  try {
    initial_size = Caml_external_polyfill.resolve("caml_ml_channel_size")(ic) - Caml_external_polyfill.resolve("caml_ml_pos_in")(ic) | 0;
  }
  catch (raw_exn){
    const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Stdlib.Sys_error) {
      initial_size = -1;
    } else {
      throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
    }
  }
  const initial_size$1 = initial_size < 0 ? 65536 : initial_size;
  const initial_size$2 = initial_size$1 <= Stdlib__Sys.max_string_length ? initial_size$1 : Stdlib__Sys.max_string_length;
  const buf = Caml_bytes.caml_create_bytes(initial_size$2);
  const nread = read_upto(ic, buf, 0, initial_size$2);
  if (nread < initial_size$2) {
    return Stdlib__Bytes.sub_string(buf, 0, nread);
  }
  let c;
  try {
    c = Caml_external_polyfill.resolve("caml_ml_input_char")(ic);
  }
  catch (raw_exn$1){
    const exn$1 = Caml_js_exceptions.internalToOCamlException(raw_exn$1);
    if (exn$1.MEL_EXN_ID === Stdlib.End_of_file) {
      return Caml_bytes.bytes_to_string(buf);
    }
    throw new Caml_js_exceptions.MelangeError(exn$1.MEL_EXN_ID, exn$1);
  }
  const buf$1 = ensure(buf, nread, 65537);
  Caml_bytes.set(buf$1, nread, c);
  let _buf = buf$1;
  let _ofs = nread + 1 | 0;
  while(true) {
    const ofs = _ofs;
    const buf$2 = _buf;
    const buf$3 = ensure(buf$2, ofs, 65536);
    const rem = buf$3.length - ofs | 0;
    const r = read_upto(ic, buf$3, ofs, rem);
    if (r < rem) {
      return Stdlib__Bytes.sub_string(buf$3, 0, ofs + r | 0);
    }
    _ofs = ofs + rem | 0;
    _buf = buf$3;
    continue ;
  };
}

function input_lines_dps(_dst, _offset, ic) {
  while(true) {
    const dst = _dst;
    const offset = _offset;
    let line;
    try {
      line = Stdlib.input_line(ic);
    }
    catch (raw_exn){
      const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
      if (exn.MEL_EXN_ID === Stdlib.End_of_file) {
        dst[offset] = /* [] */0;
        return ;
      }
      throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
      dst[offset] = undefined;
      return ;
    }
    const block = {
      hd: line,
      tl: 24029
    };
    dst[offset] = block;
    _offset = "tl";
    _dst = block;
    continue ;
  };
}

function input_lines(ic) {
  let line;
  try {
    line = Stdlib.input_line(ic);
  }
  catch (raw_exn){
    const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Stdlib.End_of_file) {
      return /* [] */0;
    }
    throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
  }
  const block = {
    hd: line,
    tl: 24029
  };
  input_lines_dps(block, "tl", ic);
  return block;
}

function fold_lines(f, _accu, ic) {
  while(true) {
    const accu = _accu;
    let line;
    try {
      line = Stdlib.input_line(ic);
    }
    catch (raw_exn){
      const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
      if (exn.MEL_EXN_ID === Stdlib.End_of_file) {
        return accu;
      }
      throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
    }
    _accu = Curry._2(f, accu, line);
    continue ;
  };
}

const stdin = Stdlib.stdin;

const open_bin = Stdlib.open_in_bin;

const open_text = Stdlib.open_in;

const open_gen = Stdlib.open_in_gen;

const close = Stdlib.close_in;

const close_noerr = Stdlib.close_in_noerr;

const input = Stdlib.input;

const set_binary_mode = Stdlib.set_binary_mode_in;

function is_binary_mode(prim) {
  return Caml_external_polyfill.resolve("caml_ml_is_binary_mode")(prim);
}

function isatty(prim) {
  return Caml_external_polyfill.resolve("caml_sys_isatty")(prim);
}

export {
  stdin ,
  open_bin ,
  open_text ,
  open_gen ,
  with_open_bin ,
  with_open_text ,
  with_open_gen ,
  close ,
  close_noerr ,
  input_char ,
  input_byte ,
  input_line ,
  really_input_string ,
  input_all ,
  input_lines ,
  input ,
  really_input ,
  fold_lines ,
  seek ,
  pos ,
  length ,
  set_binary_mode ,
  is_binary_mode ,
  isatty ,
}
/* Stdlib__Fun Not a pure module */
