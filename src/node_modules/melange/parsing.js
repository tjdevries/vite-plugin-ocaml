// Generated by Melange

import * as Caml_array from "melange.js/caml_array.js";
import * as Caml_exceptions from "melange.js/caml_exceptions.js";
import * as Caml_js_exceptions from "melange.js/caml_js_exceptions.js";
import * as Caml_obj from "melange.js/caml_obj.js";
import * as Caml_parser from "melange.js/caml_parser.js";
import * as Curry from "melange.js/curry.js";
import * as Stdlib__Array from "./array.js";
import * as Stdlib__Lexing from "./lexing.js";

const YYexit = /* @__PURE__ */Caml_exceptions.create("Stdlib.Parsing.YYexit");

const Parse_error = /* @__PURE__ */Caml_exceptions.create("Stdlib.Parsing.Parse_error");

const env = {
  s_stack: Caml_array.make(100, 0),
  v_stack: Caml_array.make(100, undefined),
  symb_start_stack: Caml_array.make(100, Stdlib__Lexing.dummy_pos),
  symb_end_stack: Caml_array.make(100, Stdlib__Lexing.dummy_pos),
  stacksize: 100,
  stackbase: 0,
  curr_char: 0,
  lval: undefined,
  symb_start: Stdlib__Lexing.dummy_pos,
  symb_end: Stdlib__Lexing.dummy_pos,
  asp: 0,
  rule_len: 0,
  rule_number: 0,
  sp: 0,
  state: 0,
  errflag: 0
};

function grow_stacks(param) {
  const oldsize = env.stacksize;
  const newsize = (oldsize << 1);
  const new_s = Caml_array.make(newsize, 0);
  const new_v = Caml_array.make(newsize, undefined);
  const new_start = Caml_array.make(newsize, Stdlib__Lexing.dummy_pos);
  const new_end = Caml_array.make(newsize, Stdlib__Lexing.dummy_pos);
  Stdlib__Array.blit(env.s_stack, 0, new_s, 0, oldsize);
  env.s_stack = new_s;
  Stdlib__Array.blit(env.v_stack, 0, new_v, 0, oldsize);
  env.v_stack = new_v;
  Stdlib__Array.blit(env.symb_start_stack, 0, new_start, 0, oldsize);
  env.symb_start_stack = new_start;
  Stdlib__Array.blit(env.symb_end_stack, 0, new_end, 0, oldsize);
  env.symb_end_stack = new_end;
  env.stacksize = newsize;
}

function clear_parser(param) {
  Stdlib__Array.fill(env.v_stack, 0, env.stacksize, undefined);
  env.lval = undefined;
}

const current_lookahead_fun = {
  contents: (function (param) {
      return false;
    })
};

function yyparse(tables, start, lexer, lexbuf) {
  const init_asp = env.asp;
  const init_sp = env.sp;
  const init_stackbase = env.stackbase;
  const init_state = env.state;
  const init_curr_char = env.curr_char;
  const init_lval = env.lval;
  const init_errflag = env.errflag;
  env.stackbase = env.sp + 1 | 0;
  env.curr_char = start;
  env.symb_end = lexbuf.lex_curr_p;
  try {
    let _cmd = /* Start */0;
    let _arg;
    while(true) {
      const arg = _arg;
      const cmd = _cmd;
      const match = Caml_parser.caml_parse_engine(tables, env, cmd, arg);
      switch (match) {
        case /* Read_token */0 :
            const t = Curry._1(lexer, lexbuf);
            env.symb_start = lexbuf.lex_start_p;
            env.symb_end = lexbuf.lex_curr_p;
            _arg = t;
            _cmd = /* Token_read */1;
            continue ;
        case /* Raise_parse_error */1 :
            throw new Caml_js_exceptions.MelangeError(Parse_error, {
                      MEL_EXN_ID: Parse_error
                    });
        case /* Grow_stacks_1 */2 :
            grow_stacks(undefined);
            _arg = undefined;
            _cmd = /* Stacks_grown_1 */2;
            continue ;
        case /* Grow_stacks_2 */3 :
            grow_stacks(undefined);
            _arg = undefined;
            _cmd = /* Stacks_grown_2 */3;
            continue ;
        case /* Compute_semantic_action */4 :
            let match$1;
            try {
              match$1 = [
                /* Semantic_action_computed */4,
                Curry._1(Caml_array.get(tables.actions, env.rule_number), env)
              ];
            }
            catch (raw_exn){
              const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
              if (exn.MEL_EXN_ID === Parse_error) {
                match$1 = [
                  /* Error_detected */5,
                  undefined
                ];
              } else {
                throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
              }
            }
            _arg = match$1[1];
            _cmd = match$1[0];
            continue ;
        case /* Call_error_function */5 :
            Curry._1(tables.error_function, "syntax error");
            _arg = undefined;
            _cmd = /* Error_detected */5;
            continue ;
        
      }
    };
  }
  catch (raw_exn$1){
    const exn$1 = Caml_js_exceptions.internalToOCamlException(raw_exn$1);
    const curr_char = env.curr_char;
    env.asp = init_asp;
    env.sp = init_sp;
    env.stackbase = init_stackbase;
    env.state = init_state;
    env.curr_char = init_curr_char;
    env.lval = init_lval;
    env.errflag = init_errflag;
    if (exn$1.MEL_EXN_ID === YYexit) {
      return exn$1._1;
    }
    current_lookahead_fun.contents = (function (tok) {
        if (typeof tok !== "number") {
          return Caml_array.get(tables.transl_block, tok.TAG | 0) === curr_char;
        } else {
          return Caml_array.get(tables.transl_const, tok) === curr_char;
        }
      });
    throw new Caml_js_exceptions.MelangeError(exn$1.MEL_EXN_ID, exn$1);
  }
}

function peek_val(env, n) {
  return Caml_array.get(env.v_stack, env.asp - n | 0);
}

function symbol_start_pos(param) {
  let _i = env.rule_len;
  while(true) {
    const i = _i;
    if (i <= 0) {
      return Caml_array.get(env.symb_end_stack, env.asp);
    }
    const st = Caml_array.get(env.symb_start_stack, (env.asp - i | 0) + 1 | 0);
    const en = Caml_array.get(env.symb_end_stack, (env.asp - i | 0) + 1 | 0);
    if (Caml_obj.caml_notequal(st, en)) {
      return st;
    }
    _i = i - 1 | 0;
    continue ;
  };
}

function symbol_end_pos(param) {
  return Caml_array.get(env.symb_end_stack, env.asp);
}

function rhs_start_pos(n) {
  return Caml_array.get(env.symb_start_stack, env.asp - (env.rule_len - n | 0) | 0);
}

function rhs_end_pos(n) {
  return Caml_array.get(env.symb_end_stack, env.asp - (env.rule_len - n | 0) | 0);
}

function symbol_start(param) {
  return symbol_start_pos(undefined).pos_cnum;
}

function symbol_end(param) {
  return symbol_end_pos(undefined).pos_cnum;
}

function rhs_start(n) {
  return rhs_start_pos(n).pos_cnum;
}

function rhs_end(n) {
  return rhs_end_pos(n).pos_cnum;
}

function is_current_lookahead(tok) {
  return Curry._1(current_lookahead_fun.contents, tok);
}

function parse_error(param) {
  
}

const set_trace = Caml_parser.caml_set_parser_trace;

export {
  symbol_start ,
  symbol_end ,
  rhs_start ,
  rhs_end ,
  symbol_start_pos ,
  symbol_end_pos ,
  rhs_start_pos ,
  rhs_end_pos ,
  clear_parser ,
  Parse_error ,
  set_trace ,
  YYexit ,
  yyparse ,
  peek_val ,
  is_current_lookahead ,
  parse_error ,
}
/* No side effect */
