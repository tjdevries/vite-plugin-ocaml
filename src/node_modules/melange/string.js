// Generated by Melange

import * as Caml from "melange.js/caml.js";
import * as Caml_bytes from "melange.js/caml_bytes.js";
import * as Caml_external_polyfill from "melange.js/caml_external_polyfill.js";
import * as Caml_js_exceptions from "melange.js/caml_js_exceptions.js";
import * as Caml_string from "melange.js/caml_string.js";
import * as Curry from "melange.js/curry.js";
import * as Stdlib from "./stdlib.js";
import * as Stdlib__Bytes from "./bytes.js";

function make(n, c) {
  return Caml_bytes.bytes_to_string(Stdlib__Bytes.make(n, c));
}

function init(n, f) {
  return Caml_bytes.bytes_to_string(Stdlib__Bytes.init(n, f));
}

function sub(s, ofs, len) {
  return Caml_bytes.bytes_to_string(Stdlib__Bytes.sub(Caml_bytes.bytes_of_string(s), ofs, len));
}

function ensure_ge(x, y) {
  if (x >= y) {
    return x;
  }
  throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
            MEL_EXN_ID: "Invalid_argument",
            _1: "String.concat"
          });
}

function sum_lengths(_acc, seplen, _param) {
  while(true) {
    const param = _param;
    const acc = _acc;
    if (!param) {
      return acc;
    }
    const hd = param.hd;
    if (!param.tl) {
      return hd.length + acc | 0;
    }
    _param = param.tl;
    _acc = ensure_ge((hd.length + seplen | 0) + acc | 0, acc);
    continue ;
  };
}

function unsafe_blits(dst, _pos, sep, seplen, _param) {
  while(true) {
    const param = _param;
    const pos = _pos;
    if (!param) {
      return dst;
    }
    const hd = param.hd;
    if (param.tl) {
      Caml_bytes.caml_blit_string(hd, 0, dst, pos, hd.length);
      Caml_bytes.caml_blit_string(sep, 0, dst, pos + hd.length | 0, seplen);
      _param = param.tl;
      _pos = (pos + hd.length | 0) + seplen | 0;
      continue ;
    }
    Caml_bytes.caml_blit_string(hd, 0, dst, pos, hd.length);
    return dst;
  };
}

function concat(sep, l) {
  if (!l) {
    return "";
  }
  const seplen = sep.length;
  return Caml_bytes.bytes_to_string(unsafe_blits(Caml_bytes.caml_create_bytes(sum_lengths(0, seplen, l)), 0, sep, seplen, l));
}

function cat(prim0, prim1) {
  return prim0 + prim1;
}

function iter(f, s) {
  for(let i = 0 ,i_finish = s.length; i < i_finish; ++i){
    Curry._1(f, s.charCodeAt(i));
  }
}

function iteri(f, s) {
  for(let i = 0 ,i_finish = s.length; i < i_finish; ++i){
    Curry._2(f, i, s.charCodeAt(i));
  }
}

function map(f, s) {
  return Caml_bytes.bytes_to_string(Stdlib__Bytes.map(f, Caml_bytes.bytes_of_string(s)));
}

function mapi(f, s) {
  return Caml_bytes.bytes_to_string(Stdlib__Bytes.mapi(f, Caml_bytes.bytes_of_string(s)));
}

function fold_right(f, x, a) {
  return Stdlib__Bytes.fold_right(f, Caml_bytes.bytes_of_string(x), a);
}

function fold_left(f, a, x) {
  return Stdlib__Bytes.fold_left(f, a, Caml_bytes.bytes_of_string(x));
}

function exists(f, s) {
  return Stdlib__Bytes.exists(f, Caml_bytes.bytes_of_string(s));
}

function for_all(f, s) {
  return Stdlib__Bytes.for_all(f, Caml_bytes.bytes_of_string(s));
}

function is_space(param) {
  if (param > 13 || param < 9) {
    return param === 32;
  } else {
    return param !== 11;
  }
}

function trim(s) {
  if (s === "" || !(is_space(s.charCodeAt(0)) || is_space(s.charCodeAt(s.length - 1 | 0)))) {
    return s;
  } else {
    return Caml_bytes.bytes_to_string(Stdlib__Bytes.trim(Caml_bytes.bytes_of_string(s)));
  }
}

function escaped(s) {
  const b = Caml_bytes.bytes_of_string(s);
  return Caml_bytes.bytes_to_string(Stdlib__Bytes.unsafe_escape(b));
}

function index_rec(s, lim, _i, c) {
  while(true) {
    const i = _i;
    if (i >= lim) {
      throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
                MEL_EXN_ID: Stdlib.Not_found
              });
    }
    if (s.charCodeAt(i) === c) {
      return i;
    }
    _i = i + 1 | 0;
    continue ;
  };
}

function index(s, c) {
  return index_rec(s, s.length, 0, c);
}

function index_rec_opt(s, lim, _i, c) {
  while(true) {
    const i = _i;
    if (i >= lim) {
      return ;
    }
    if (s.charCodeAt(i) === c) {
      return i;
    }
    _i = i + 1 | 0;
    continue ;
  };
}

function index_opt(s, c) {
  return index_rec_opt(s, s.length, 0, c);
}

function index_from(s, i, c) {
  const l = s.length;
  if (i < 0 || i > l) {
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
              MEL_EXN_ID: "Invalid_argument",
              _1: "String.index_from / Bytes.index_from"
            });
  }
  return index_rec(s, l, i, c);
}

function index_from_opt(s, i, c) {
  const l = s.length;
  if (i < 0 || i > l) {
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
              MEL_EXN_ID: "Invalid_argument",
              _1: "String.index_from_opt / Bytes.index_from_opt"
            });
  }
  return index_rec_opt(s, l, i, c);
}

function rindex_rec(s, _i, c) {
  while(true) {
    const i = _i;
    if (i < 0) {
      throw new Caml_js_exceptions.MelangeError(Stdlib.Not_found, {
                MEL_EXN_ID: Stdlib.Not_found
              });
    }
    if (s.charCodeAt(i) === c) {
      return i;
    }
    _i = i - 1 | 0;
    continue ;
  };
}

function rindex(s, c) {
  return rindex_rec(s, s.length - 1 | 0, c);
}

function rindex_from(s, i, c) {
  if (i < -1 || i >= s.length) {
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
              MEL_EXN_ID: "Invalid_argument",
              _1: "String.rindex_from / Bytes.rindex_from"
            });
  }
  return rindex_rec(s, i, c);
}

function rindex_rec_opt(s, _i, c) {
  while(true) {
    const i = _i;
    if (i < 0) {
      return ;
    }
    if (s.charCodeAt(i) === c) {
      return i;
    }
    _i = i - 1 | 0;
    continue ;
  };
}

function rindex_opt(s, c) {
  return rindex_rec_opt(s, s.length - 1 | 0, c);
}

function rindex_from_opt(s, i, c) {
  if (i < -1 || i >= s.length) {
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
              MEL_EXN_ID: "Invalid_argument",
              _1: "String.rindex_from_opt / Bytes.rindex_from_opt"
            });
  }
  return rindex_rec_opt(s, i, c);
}

function contains_from(s, i, c) {
  const l = s.length;
  if (i < 0 || i > l) {
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
              MEL_EXN_ID: "Invalid_argument",
              _1: "String.contains_from / Bytes.contains_from"
            });
  }
  try {
    index_rec(s, l, i, c);
    return true;
  }
  catch (raw_exn){
    const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Stdlib.Not_found) {
      return false;
    }
    throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
  }
}

function contains(s, c) {
  return contains_from(s, 0, c);
}

function rcontains_from(s, i, c) {
  if (i < 0 || i >= s.length) {
    throw new Caml_js_exceptions.MelangeError("Invalid_argument", {
              MEL_EXN_ID: "Invalid_argument",
              _1: "String.rcontains_from / Bytes.rcontains_from"
            });
  }
  try {
    rindex_rec(s, i, c);
    return true;
  }
  catch (raw_exn){
    const exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.MEL_EXN_ID === Stdlib.Not_found) {
      return false;
    }
    throw new Caml_js_exceptions.MelangeError(exn.MEL_EXN_ID, exn);
  }
}

function uppercase_ascii(s) {
  return Caml_bytes.bytes_to_string(Stdlib__Bytes.uppercase_ascii(Caml_bytes.bytes_of_string(s)));
}

function lowercase_ascii(s) {
  return Caml_bytes.bytes_to_string(Stdlib__Bytes.lowercase_ascii(Caml_bytes.bytes_of_string(s)));
}

function capitalize_ascii(s) {
  return Caml_bytes.bytes_to_string(Stdlib__Bytes.capitalize_ascii(Caml_bytes.bytes_of_string(s)));
}

function uncapitalize_ascii(s) {
  return Caml_bytes.bytes_to_string(Stdlib__Bytes.uncapitalize_ascii(Caml_bytes.bytes_of_string(s)));
}

function starts_with(prefix, s) {
  const len_s = s.length;
  const len_pre = prefix.length;
  if (len_s >= len_pre) {
    let _i = 0;
    while(true) {
      const i = _i;
      if (i === len_pre) {
        return true;
      }
      if (s.charCodeAt(i) !== prefix.charCodeAt(i)) {
        return false;
      }
      _i = i + 1 | 0;
      continue ;
    };
  } else {
    return false;
  }
}

function ends_with(suffix, s) {
  const len_s = s.length;
  const len_suf = suffix.length;
  const diff = len_s - len_suf | 0;
  if (diff >= 0) {
    let _i = 0;
    while(true) {
      const i = _i;
      if (i === len_suf) {
        return true;
      }
      if (s.charCodeAt(diff + i | 0) !== suffix.charCodeAt(i)) {
        return false;
      }
      _i = i + 1 | 0;
      continue ;
    };
  } else {
    return false;
  }
}

function hash(x) {
  return Caml_external_polyfill.resolve("caml_string_hash")(0, x);
}

function split_on_char(sep, s) {
  let r = /* [] */0;
  let j = s.length;
  for(let i = s.length - 1 | 0; i >= 0; --i){
    if (s.charCodeAt(i) === sep) {
      r = {
        hd: sub(s, i + 1 | 0, (j - i | 0) - 1 | 0),
        tl: r
      };
      j = i;
    }
    
  }
  return {
          hd: sub(s, 0, j),
          tl: r
        };
}

const compare = Caml.caml_string_compare;

function to_seq(s) {
  return Stdlib__Bytes.to_seq(Caml_bytes.bytes_of_string(s));
}

function to_seqi(s) {
  return Stdlib__Bytes.to_seqi(Caml_bytes.bytes_of_string(s));
}

function of_seq(g) {
  return Caml_bytes.bytes_to_string(Stdlib__Bytes.of_seq(g));
}

function get_utf_8_uchar(s, i) {
  return Stdlib__Bytes.get_utf_8_uchar(Caml_bytes.bytes_of_string(s), i);
}

function is_valid_utf_8(s) {
  return Stdlib__Bytes.is_valid_utf_8(Caml_bytes.bytes_of_string(s));
}

function get_utf_16be_uchar(s, i) {
  return Stdlib__Bytes.get_utf_16be_uchar(Caml_bytes.bytes_of_string(s), i);
}

function is_valid_utf_16be(s) {
  return Stdlib__Bytes.is_valid_utf_16be(Caml_bytes.bytes_of_string(s));
}

function get_utf_16le_uchar(s, i) {
  return Stdlib__Bytes.get_utf_16le_uchar(Caml_bytes.bytes_of_string(s), i);
}

function is_valid_utf_16le(s) {
  return Stdlib__Bytes.is_valid_utf_16le(Caml_bytes.bytes_of_string(s));
}

function get_int8(s, i) {
  return Stdlib__Bytes.get_int8(Caml_bytes.bytes_of_string(s), i);
}

function get_uint16_le(s, i) {
  return Stdlib__Bytes.get_uint16_le(Caml_bytes.bytes_of_string(s), i);
}

function get_uint16_be(s, i) {
  return Stdlib__Bytes.get_uint16_be(Caml_bytes.bytes_of_string(s), i);
}

function get_int16_ne(s, i) {
  return Stdlib__Bytes.get_int16_ne(Caml_bytes.bytes_of_string(s), i);
}

function get_int16_le(s, i) {
  return Stdlib__Bytes.get_int16_le(Caml_bytes.bytes_of_string(s), i);
}

function get_int16_be(s, i) {
  return Stdlib__Bytes.get_int16_be(Caml_bytes.bytes_of_string(s), i);
}

function get_int32_le(s, i) {
  return Stdlib__Bytes.get_int32_le(Caml_bytes.bytes_of_string(s), i);
}

function get_int32_be(s, i) {
  return Stdlib__Bytes.get_int32_be(Caml_bytes.bytes_of_string(s), i);
}

function get_int64_le(s, i) {
  return Stdlib__Bytes.get_int64_le(Caml_bytes.bytes_of_string(s), i);
}

function get_int64_be(s, i) {
  return Stdlib__Bytes.get_int64_be(Caml_bytes.bytes_of_string(s), i);
}

const empty = "";

const of_bytes = Stdlib__Bytes.to_string;

const to_bytes = Stdlib__Bytes.of_string;

const blit = Stdlib__Bytes.blit_string;

function equal(prim0, prim1) {
  return prim0 === prim1;
}

const get_uint8 = Caml_string.get;

const get_uint16_ne = Caml_bytes.get16;

const get_int32_ne = Caml_bytes.get32;

const get_int64_ne = Caml_bytes.get64;

function seeded_hash(prim0, prim1) {
  return Caml_external_polyfill.resolve("caml_string_hash")(prim0, prim1);
}

export {
  make ,
  init ,
  empty ,
  of_bytes ,
  to_bytes ,
  blit ,
  concat ,
  cat ,
  equal ,
  compare ,
  starts_with ,
  ends_with ,
  contains_from ,
  rcontains_from ,
  contains ,
  sub ,
  split_on_char ,
  map ,
  mapi ,
  fold_left ,
  fold_right ,
  for_all ,
  exists ,
  trim ,
  escaped ,
  uppercase_ascii ,
  lowercase_ascii ,
  capitalize_ascii ,
  uncapitalize_ascii ,
  iter ,
  iteri ,
  index_from ,
  index_from_opt ,
  rindex_from ,
  rindex_from_opt ,
  index ,
  index_opt ,
  rindex ,
  rindex_opt ,
  to_seq ,
  to_seqi ,
  of_seq ,
  get_utf_8_uchar ,
  is_valid_utf_8 ,
  get_utf_16be_uchar ,
  is_valid_utf_16be ,
  get_utf_16le_uchar ,
  is_valid_utf_16le ,
  get_uint8 ,
  get_int8 ,
  get_uint16_ne ,
  get_uint16_be ,
  get_uint16_le ,
  get_int16_ne ,
  get_int16_be ,
  get_int16_le ,
  get_int32_ne ,
  get_int32_be ,
  get_int32_le ,
  get_int64_ne ,
  get_int64_be ,
  get_int64_le ,
  hash ,
  seeded_hash ,
}
/* No side effect */
